#!/usr/bin/env python3
from __future__ import annotations
# mcp: è½»é‡å‘½ä»¤è¡Œï¼Œç”¨äºæŒ‰éœ€å¯ç”¨/ç¦ç”¨ MCP æœåŠ¡å™¨ã€åº”ç”¨é…ç½®é›†(profile)ï¼Œ
#      å¹¶å°†æ‰€é€‰é›†åˆè½åœ°åˆ°æŒ‡å®š CLI/IDEï¼ˆä¸å†æä¾› nvm ç›¸å…³åˆ‡æ¢ï¼‰ã€‚

import argparse, json, os, re, shutil, subprocess, sys, platform
from pathlib import Path

# Import validation module with graceful fallback
try:
    from mcp_validation import (
        validate_mcp_servers_config, 
        MCPValidationError, 
        MCPSchemaError, 
        MCPConfigError,
        format_validation_error
    )
    VALIDATION_AVAILABLE = True
except ImportError:
    # Fallback when validation module is not available
    VALIDATION_AVAILABLE = False
    def validate_mcp_servers_config(config_path): return {}
    class MCPValidationError(Exception): pass
    class MCPSchemaError(Exception): pass
    class MCPConfigError(Exception): pass
    def format_validation_error(error): return f"âŒ é…ç½®é”™è¯¯: {str(error)}"

HOME = Path.home()
CENTRAL = HOME/'.mcp-central'/'config'/'mcp-servers.json'

# å…¨å±€å¼€å…³ï¼šdry-runï¼ˆä»…é¢„è§ˆï¼Œä¸è½åœ°ï¼‰
DRY_RUN = False

def load_json(p: Path, default, error_context: str = ""):
    """Load JSON file with enhanced error handling.
    
    Args:
        p: Path to the JSON file
        default: Default value to return on error
        error_context: Additional context for error messages
        
    Returns:
        Parsed JSON object or default value
    """
    if not p.exists():
        return default
    try:
        content = p.read_text(encoding='utf-8')
        if not content.strip():
            if error_context:
                print(f"âš ï¸ è­¦å‘Š: {error_context} - æ–‡ä»¶ä¸ºç©º: {p}", file=sys.stderr)
            return default
        return json.loads(content)
    except json.JSONDecodeError as e:
        if error_context:
            print(f"âŒ {error_context} - JSON è§£æé”™è¯¯: {p}", file=sys.stderr)
            print(f"   é”™è¯¯ä½ç½®: è¡Œ {e.lineno}, åˆ— {e.colno}", file=sys.stderr)
            if e.msg:
                print(f"   é”™è¯¯ä¿¡æ¯: {e.msg}", file=sys.stderr)
        return default
    except Exception as e:
        if error_context:
            print(f"âŒ {error_context} - è¯»å–æ–‡ä»¶å¤±è´¥: {p}", file=sys.stderr)
            print(f"   é”™è¯¯ä¿¡æ¯: {e}", file=sys.stderr)
        return default

def save_json(p: Path, obj: dict):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding='utf-8')

def backup(p: Path):
    if not p.exists():
        return None
    ts = __import__('datetime').datetime.now().strftime('%Y%m%d_%H%M%S')
    b = p.with_suffix(f'.{ts}.backup')
    shutil.copy2(p, b)
    return b

def load_central_servers():
    """Load central MCP servers configuration with validation.
    
    Returns:
        tuple: (config_dict, servers_dict)
    """
    # First try to validate the configuration
    validation_passed = False
    obj = {}
    
    if VALIDATION_AVAILABLE and CENTRAL.exists():
        try:
            obj = validate_mcp_servers_config(CENTRAL)
            validation_passed = True
            print("âœ… ä¸­å¤®é…ç½®å·²é€šè¿‡ schema éªŒè¯", file=sys.stderr) if getattr(load_central_servers, '_verbose', False) else None
        except (MCPValidationError, MCPSchemaError) as e:
            print(format_validation_error(e), file=sys.stderr)
            print("âš ï¸  è­¦å‘Š: Schema éªŒè¯å¤±è´¥ï¼Œä½¿ç”¨åŸºæœ¬ JSON è§£æï¼ˆåŠŸèƒ½å¯èƒ½å—é™ï¼‰", file=sys.stderr)
            # Fall back to basic JSON loading
            obj = load_json(CENTRAL, {}, "ä¸­å¤®é…ç½®éªŒè¯å¤±è´¥")
        except Exception as e:
            print(f"âŒ éªŒè¯è¿‡ç¨‹å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}", file=sys.stderr)
            print("âš ï¸  è­¦å‘Š: ä½¿ç”¨åŸºæœ¬ JSON è§£æ", file=sys.stderr)
            obj = load_json(CENTRAL, {}, "ä¸­å¤®é…ç½®éªŒè¯å¼‚å¸¸")
    else:
        # Validation not available, use basic loading
        obj = load_json(CENTRAL, {}, "ä¸­å¤®é…ç½®åŠ è½½")
    
    # Extract servers with error handling
    servers = obj.get('servers') or {}
    if not isinstance(servers, dict):
        print("âŒ é”™è¯¯: 'servers' å­—æ®µå¿…é¡»æ˜¯å¯¹è±¡æ ¼å¼", file=sys.stderr)
        servers = {}
    
    # Validate individual servers if validation is available
    if VALIDATION_AVAILABLE and validation_passed:
        from mcp_validation import validate_server_config
        for server_name, server_info in servers.items():
            try:
                validate_server_config(server_name, server_info)
            except MCPValidationError as e:
                print(f"âš ï¸  æœåŠ¡å™¨é…ç½®è­¦å‘Š - {server_name}: {e}", file=sys.stderr)
    
    return obj, servers

def write_central_servers(obj):
    backup(CENTRAL)
    save_json(CENTRAL, obj)

# æ³¨ï¼šå·²ç§»é™¤ nvm ä¸ä¸­å¤®æ¸…å•å¼€å…³æ§åˆ¶é€»è¾‘

def list_servers():
    obj, servers = load_central_servers()
    rows = []
    for n, v in sorted(servers.items()):
        en = bool(v.get('enabled', True))
        cmd = v.get('command','')
        rows.append((n, 'on' if en else 'off', cmd))
    print("ä¸­å¤®æ¸…å•ï¼ˆå¯ç”¨å¼€å…³ä¸å‘½ä»¤è·¯å¾„ï¼‰")
    print("name                        state  command")
    print("-"*60)
    for n,st,cmd in rows:
        print(f"{n:26} {st:5}  {cmd}")

def _json_keys(path: Path, pref_key='mcpServers', error_context: str = ""):
    """Extract keys from JSON file with error handling.
    
    Args:
        path: Path to the JSON file
        pref_key: Preferred key to look for
        error_context: Context for error messages
        
    Returns:
        set: Set of keys found
    """
    obj = load_json(path, {}, error_context or f"è¯»å– {path.name} é…ç½®")
    if isinstance(obj.get(pref_key), dict):
        return set(obj[pref_key].keys())
    if isinstance(obj.get('servers'), dict):
        return set(obj['servers'].keys())
    return set()

def _codex_keys():
    p = HOME/'.codex'/'config.toml'
    if not p.exists():
        return set()
    try:
        import tomllib
        conf = tomllib.loads(p.read_text(encoding='utf-8'))
        m = conf.get('mcp_servers', {}) or {}
        return {k for k in m.keys() if not k.endswith('.env')}
    except Exception:
        # ç®€æ˜“å›é€€ï¼šæ­£åˆ™æå– [mcp_servers.NAME] æ®µ
        import re
        names = set()
        for line in p.read_text(encoding='utf-8').splitlines():
            line = line.strip()
            m = re.match(r"^\[mcp_servers\.([^\]]+)\]$", line)
            if m:
                name = m.group(1)
                if not name.endswith('.env'):
                    names.add(name)
        return names

def _claude_registered():
    """æ›´ç¨³å¥åœ°è¯»å– Claude æ³¨å†Œè¡¨ã€‚
    - å»¶é•¿è¶…æ—¶ï¼ˆ30sï¼‰ï¼Œé€‚é…â€œClaude Code æ™ºèƒ½å¯åŠ¨â€çš„ç½‘ç»œæ¢æµ‹
    - åˆå¹¶ stdout+stderr è§£æï¼Œé¿å…åªè¯» stdout æ¼é¡¹
    """
    try:
        # æµ‹è¯•/CI ç¯å¢ƒå¯èƒ½æ—  Claude æˆ–è¾“å‡ºé˜»å¡ï¼Œå°†è¶…æ—¶é™åˆ° 3sï¼Œå¹¶å…è®¸é€šè¿‡ CLAUDE_LIST_TIMEOUT ç§’è¦†ç›–
        t = float(os.environ.get('CLAUDE_LIST_TIMEOUT', '3'))
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=t)
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        reg = set()
        for line in text.splitlines():
            if ':' in line:
                reg.add(line.split(':',1)[0].strip())
        return reg
    except Exception:
        return set()

def _print_client(label, present, universe):
    present = sorted(present)
    absent = sorted(set(universe) - set(present))
    print(f"\n[{label}]")
    print("  on : "+ (', '.join(present) if present else 'æ— '))
    print("  off: "+ (', '.join(absent) if absent else 'æ— '))

def _normalize_client(alias: str|None):
    if not alias:
        return None
    a = alias.strip().lower()
    mapping = {
        'claude': 'claude-file',
        'claude-file': 'claude-file',
        'claude-reg': 'claude-reg',
        'codex': 'codex',
        'gemini': 'gemini',
        'iflow': 'iflow',
        'droid': 'droid',
        'cursor': 'cursor',
        'vscode': 'vscode-user',
        'vscode-user': 'vscode-user',
        'vscode-insiders': 'vscode-ins',
        'vscode-ins': 'vscode-ins',
        'insiders': 'vscode-ins',
    }
    return mapping.get(a)

def _expand_tilde(v):
    if isinstance(v, str):
        try:
            return os.path.expanduser(v)
        except Exception:
            return v
    return v

def _expand_entry(entry: dict):
    if not isinstance(entry, dict):
        return entry
    e = dict(entry)
    if 'command' in e:
        e['command'] = _expand_tilde(e['command'])
    if 'args' in e and isinstance(e['args'], list):
        e['args'] = [_expand_tilde(a) for a in e['args']]
    return e

def _is_macos():
    # å…è®¸é€šè¿‡ MCP_OS=darwin è¦†ç›–ï¼Œä¾¿äºæµ‹è¯•
    v = os.environ.get('MCP_OS')
    if v:
        return v.lower() in ('darwin','mac','macos','osx')
    return platform.system() == 'Darwin'

def _vscode_user_path():
    if _is_macos():
        return HOME/'Library'/'Application Support'/'Code'/'User'/'mcp.json'
    return HOME/'.config'/'Code'/'User'/'mcp.json'

def _vscode_insiders_path():
    if _is_macos():
        return HOME/'Library'/'Application Support'/'Code - Insiders'/'User'/'mcp.json'
    return HOME/'.config'/'Code - Insiders'/'User'/'mcp.json'

def cmd_status(args):
    """æ˜¾ç¤º MCP æœåŠ¡å™¨çŠ¶æ€ï¼ŒåŒ…æ‹¬ä¸­å¤®é…ç½®å’Œå„å®¢æˆ·ç«¯çš„å®é™…å¯ç”¨çŠ¶æ€"""
    try:
        obj, servers = load_central_servers()
    except Exception as e:
        print(f"âŒ åŠ è½½ä¸­å¤®é…ç½®å¤±è´¥: {e}", file=sys.stderr)
        print("âš ï¸  å°è¯•ä½¿ç”¨é»˜è®¤é…ç½®ç»§ç»­...", file=sys.stderr)
        servers = {}
        obj = {}
    
    central_names = sorted(servers.keys())
    print(f"ğŸ“Š ä¸­å¤®é…ç½®ä¸­çš„æœåŠ¡å™¨æ•°é‡: {len(central_names)}", file=sys.stderr)
    
    # å¯é€‰æ˜¾ç¤ºä¸­å¤®æ¸…å•
    if args.central:
        list_servers()
    
    # å®¢æˆ·ç«¯/IDE è§†å›¾ï¼ˆå¯é€‰è¿‡æ»¤ï¼‰
    # å…è®¸ä½ç½®å‚æ•° client_pos æˆ– --clientï¼›å¹¶æ”¯æŒç®€å†™åˆ«å
    sel = _normalize_client(getattr(args, 'client_pos', None)) or _normalize_client(args.client)
    targets = [
        ('claude-file', 'Claude(file)', lambda: _json_keys(HOME/'.claude'/'settings.json', 'mcpServers', 'Claudeé…ç½®è¯»å–')),
        ('claude-reg',  'Claude(register)', _claude_registered),
        ('codex',       'Codex', _codex_keys),
        ('gemini',      'Gemini', lambda: _json_keys(HOME/'.gemini'/'settings.json', 'mcpServers', 'Geminié…ç½®è¯»å–')),
        ('iflow',       'iFlow', lambda: _json_keys(HOME/'.iflow'/'settings.json', 'mcpServers', 'iFlowé…ç½®è¯»å–')),
        ('droid',       'Droid', lambda: _json_keys(HOME/'.factory'/'mcp.json', 'mcpServers', 'Droidé…ç½®è¯»å–')),
        ('cursor',      'Cursor', lambda: _json_keys(HOME/'.cursor'/'mcp.json', 'mcpServers', 'Cursoré…ç½®è¯»å–')),
        ('vscode-user', 'VS Code(User)', lambda: _json_keys(_vscode_user_path(), 'servers', 'VS Codeé…ç½®è¯»å–')),
        ('vscode-ins',  'VS Code(Insiders)', lambda: _json_keys(_vscode_insiders_path(), 'servers', 'VS Code Insidersé…ç½®è¯»å–')),
    ]
    print("â€” æŒ‰å®¢æˆ·ç«¯/IDE çš„å®é™…å¯ç”¨è§†å›¾ â€”")
    for key, label, fn in targets:
        if sel and sel != key:
            continue
        try:
            present = fn()
            if args.verbose:
                print(f"ğŸ” {label}: æ‰¾åˆ° {len(present)} ä¸ªå·²é…ç½®æœåŠ¡å™¨", file=sys.stderr)
        except Exception as e:
            if args.verbose:
                print(f"âš ï¸  {label}: è¯»å–é…ç½®æ—¶å‡ºé”™ - {e}", file=sys.stderr)
            present = set()
        _print_client(label, present, central_names)

def cmd_run(args):
    # å…ˆåº”ç”¨åˆ°æŒ‡å®šå®¢æˆ·ç«¯
    subset = build_subset(args.servers.split(','))
    if not subset:
        print('[ERR] æœåŠ¡å™¨åæ— æ•ˆæˆ–ä¸ºç©º')
        return 1
    client = args.client
    if client == 'claude':
        rc = apply_claude(subset, verbose=getattr(args,'verbose',False))
    elif client == 'codex':
        rc = apply_codex(subset)
    elif client == 'gemini':
        rc = apply_json_map('Gemini', HOME/'.gemini'/'settings.json', subset, 'mcpServers')
    elif client == 'iflow':
        rc = apply_json_map('iFlow', HOME/'.iflow'/'settings.json', subset, 'mcpServers')
    elif client == 'droid':
        # å†™å…¥ ~/.factory/mcp.json çš„ mcpServersï¼Œå¹¶â€œå…ˆ remove å† addâ€å¼ºåˆ¶å¯¹é½æ³¨å†Œè¡¨
        rc = apply_json_map('Droid', HOME/'.factory'/'mcp.json', subset, 'mcpServers')
        want=set(subset.keys())
        obj,_ = load_central_servers()
        servers = obj.get('servers') or {}
        if DRY_RUN:
            print('[DRY-RUN] å°†å¯¹é½ Droid æ³¨å†Œï¼ˆé¢„è§ˆï¼šå…ˆ remove å† addï¼‰')
            print('  keys:', ', '.join(sorted(want)) if want else '(none)')
            for n in sorted(want):
                info = servers.get(n) or {}
                cmd_str = ' '.join([_expand_tilde(info.get('command',''))] + [ _expand_tilde(str(a)) for a in (info.get('args') or []) ])
                print('[DRY-RUN]', ' '.join(['droid','mcp','remove', n]))
                cmd = ['droid','mcp','add', n, cmd_str]
                for k,v in (info.get('env') or {}).items():
                    cmd += ['--env', f'{k}={v}']
                print('[DRY-RUN]', ' '.join(cmd))
        else:
            for n in sorted(want):
                # å…ˆç§»é™¤ï¼Œå¿½ç•¥é”™è¯¯
                try:
                    subprocess.run(['droid','mcp','remove', n], check=False, timeout=10)
                except Exception:
                    pass
                # å†æ·»åŠ ï¼ˆdroid è¯­æ³•ï¼šdroid mcp add <name> "<command and args>")
                info = servers.get(n) or {}
                cmd_str = ' '.join([_expand_tilde(info.get('command',''))] + [ _expand_tilde(str(a)) for a in (info.get('args') or []) ])
                cmd = ['droid','mcp','add', n, cmd_str]
                for k,v in (info.get('env') or {}).items():
                    cmd += ['--env', f'{k}={v}']
                try:
                    if getattr(args,'verbose',False):
                        print('[VERBOSE]', ' '.join(cmd))
                    subprocess.run(cmd, check=False, timeout=30)
                except Exception:
                    pass
    elif client == 'cursor':
        rc = apply_json_map('Cursor', HOME/'.cursor'/'mcp.json', subset, 'mcpServers')
    elif client == 'vscode-user':
        rc = apply_json_map('VS Code(User)', _vscode_user_path(), subset, 'servers')
    elif client == 'vscode-insiders':
        rc = apply_json_map('VS Code(Insiders)', _vscode_insiders_path(), subset, 'servers')
    else:
        print('[ERR] æœªçŸ¥ client')
        return 2
    
    if isinstance(rc, int) and rc != 0:
        return rc
    # æ‰§è¡Œå‘½ä»¤
    exec_cmd = args.exec or []
    while exec_cmd and exec_cmd[0] == '--':
        exec_cmd.pop(0)
    if not exec_cmd:
        # é»˜è®¤æ˜ å°„ï¼šclaude -> ['claude']
        if args.client.startswith('claude'):
            exec_cmd = ['claude']
        elif args.client == 'codex':
            exec_cmd = ['codex']
    if not exec_cmd:
        print('[OK] å·²åº”ç”¨æ‰€é€‰é›†åˆï¼›æœªæä¾›å¯åŠ¨å‘½ä»¤ï¼Œç»“æŸã€‚')
        return 0
    if DRY_RUN:
        print('[DRY-RUN] å°†æ‰§è¡Œå‘½ä»¤ï¼ˆé¢„è§ˆï¼‰ï¼š', ' '.join(exec_cmd))
        return 0
    os.execvp(exec_cmd[0], exec_cmd)

## å·²ç§»é™¤ï¼šcmd_on/cmd_off/cmd_onlyï¼ˆä¸­å¤®æ¸…å•å¼€å…³ä¸å†ä½œä¸ºå…¥å£ï¼‰

## å·²ç§»é™¤ï¼šcmd_enable_allï¼ˆé»˜è®¤è§†ä¸ºå…¨éƒ¨å¯ç”¨ï¼‰

 

def cmd_sync(args):
    here = Path(__file__).resolve().parent.parent
    sync_py = here/'bin'/'mcp-auto-sync.py'
    rc = subprocess.call([sys.executable, str(sync_py), 'sync'])
    sys.exit(rc)

def cmd_check(args):
    # è½»é‡ç‰ˆåªè¯»ä½“æ£€ï¼šé¿å…åœ¨æ— ä¾èµ–ç¯å¢ƒä¸­å¡ä½ï¼›éœ€è¦æ›´æ·±å…¥ä½“æ£€æ—¶å¯ç›´æ¥è¿è¡Œ scripts/mcp-check.sh
    print('MCP å¥åº·æ£€æŸ¥æŠ¥å‘Š')
    # å±•ç¤ºä¸­å¤®æ¸…å•ä½ç½®ä¸å…³é”®è·¯å¾„å­˜åœ¨æ€§
    print(f"- ä¸­å¤®æ¸…å•: {CENTRAL}")
    for label, path in [
        ('Claude æ–‡ä»¶', HOME/'.claude'/'settings.json'),
        ('Codex TOML', HOME/'.codex'/'config.toml'),
        ('Gemini æ–‡ä»¶', HOME/'.gemini'/'settings.json'),
        ('iFlow æ–‡ä»¶', HOME/'.iflow'/'settings.json'),
        ('Droid æ–‡ä»¶', HOME/'.factory'/'mcp.json'),
        ('Cursor æ–‡ä»¶', HOME/'.cursor'/'mcp.json'),
        ('VS Code(User)', _vscode_user_path()),
        ('VS Code(Insiders)', _vscode_insiders_path()),
    ]:
        state = 'å­˜åœ¨' if path.exists() else 'ç¼ºå¤±'
        print(f"  [INFO] {label}: {path} ({state})")
    print('\nç»“è®º: æœ€å°ä½“æ£€å®Œæˆï¼ˆå¦‚éœ€æ·±åº¦ä½“æ£€ï¼Œè¯·æ‰§è¡Œ scripts/mcp-check.shï¼‰')
    return 0

def build_subset(names):
    obj, servers = load_central_servers()
    sel = {}
    for n in names:
        if n in servers:
            sel[n] = servers[n]
    return sel

def _strip_toml_mcp_servers_block(text: str) -> str:
    """ä» Codex çš„ config.toml ä¸­ç§»é™¤æ‰€æœ‰ [mcp_servers.*] æ®µè½ä¸æˆ‘ä»¬å†™å…¥çš„æ ‡è®°å—ã€‚"""
    text = re.sub(r"\n*# === MCP Servers é…ç½®ï¼ˆç”± MCP (?:Local Manager|Central) ç”Ÿæˆï¼‰===\n(?:.|\n)*?(?=\n?# ===|\Z)", "\n", text)
    text = re.sub(r"(?ms)^\[mcp_servers\.[^\]]+\][\s\S]*?(?=^\[|\Z)", "", text)
    return text

def apply_codex(subset):
    p = HOME/'.codex'/'config.toml'
    if not p.exists():
        print(f"[ERR] Codex é…ç½®ä¸å­˜åœ¨: {p}")
        return 1
    keys = sorted(list(subset.keys()))
    if DRY_RUN:
        print(f"[DRY-RUN] å°†åº”ç”¨åˆ° Codex: {p}")
        print("  keys:", ', '.join(keys) if keys else '(none)')
        return 0
    backup(p)
    text = p.read_text(encoding='utf-8')
    # æ¸…ç†æ—§å— + æ‰€æœ‰ [mcp_servers.*]
    text = _strip_toml_mcp_servers_block(text)
    lines = ["\n# === MCP Servers é…ç½®ï¼ˆç”± MCP Local Manager ç”Ÿæˆï¼‰==="]
    for name,info in subset.items():
        lines.append(f"\n[mcp_servers.{name}]")
        # Codex: å¢åŠ å¯åŠ¨è¶…æ—¶ï¼Œé¿å…é»˜è®¤ 10s è¶…æ—¶ï¼ˆnpx é¦–æ¬¡æ‹‰å–è¾ƒæ…¢ï¼‰
        lines.append("startup_timeout_sec = 60")
        lines.append(f"command = \"{info.get('command','')}\"")
        args = info.get('args') or []
        if args:
            lines.append('args = ' + json.dumps(args))
        env = info.get('env') or {}
        if env:
            lines.append(f"\n[mcp_servers.{name}.env]")
            for k,v in env.items():
                lines.append(f"{k} = \"{v}\"")
    new_block='\n'.join(lines)+"\n"
    p.write_text(text.rstrip()+"\n"+new_block, encoding='utf-8')
    print(f"[OK] å·²åº”ç”¨åˆ° Codex: {p}")
    return 0

def _clear_json_map(label: str, path: Path, top_key='mcpServers', extra: str|None=None):
    """å°† JSON é…ç½®ä¸­çš„ MCP èŠ‚ç‚¹æ¸…ç©ºï¼ˆå¹¶å¤‡ä»½ï¼‰ã€‚
    - top_key ä¸º 'servers' æˆ– 'mcpServers' ç­‰
    - extra å¯é€‰ï¼šä¾‹å¦‚ 'gemini.allowed'ï¼Œä¼šé¢å¤–æ¸…ç©º
    """
    if DRY_RUN:
        print(f"[DRY-RUN] å°†æ¸…ç©º {label} çš„é…ç½®: {path}")
        return 0
    if not path.exists():
        print(f"[INFO] è·³è¿‡ {label}ï¼ˆé…ç½®ä¸å­˜åœ¨ï¼‰: {path}")
        return 0
    obj = load_json(path, {})
    if top_key == 'servers':
        obj['servers'] = {}
    else:
        obj[top_key] = {}
        if label.startswith('Gemini'):
            obj.setdefault('mcp', {})['allowed'] = []
    if extra == 'gemini.allowed':
        obj.setdefault('mcp', {})['allowed'] = []
    backup(path)
    save_json(path, obj)
    print(f"[OK] å·²æ¸…ç©º {label}: {path}")
    return 0

def _clear_claude_registry(verbose: bool=False):
    """ç§»é™¤ Claude CLI çš„ mcp æ³¨å†Œè¡¨æ¡ç›®ã€‚"""
    if DRY_RUN:
        print('[DRY-RUN] å°†æ¸…ç©º Claude æ³¨å†Œè¡¨ï¼ˆé¢„è§ˆï¼Œè·³è¿‡ `claude mcp list`ï¼‰')
        return 0
    try:
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=30)
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        names = []
        for line in text.splitlines():
            if ':' in line:
                names.append(line.split(':',1)[0].strip())
    except Exception:
        names = []
    if not names:
        if verbose:
            print('[INFO] Claude æ³¨å†Œè¡¨æ— æ¡ç›®éœ€æ¸…ç†')
        return 0
    if DRY_RUN:
        for n in names:
            print('[DRY-RUN]', 'claude mcp remove', n)
        return 0
    ok=0; fail=0
    for n in names:
        try:
            cmd = ['claude','mcp','remove', n]
            if verbose:
                print('[VERBOSE]', ' '.join(cmd))
            r = subprocess.run(cmd, check=False, timeout=10)
            ok += 1 if r.returncode == 0 else 0
            fail += 1 if r.returncode != 0 else 0
        except Exception:
            fail += 1
    print(f"[OK] å·²æ¸…ç† Claude æ³¨å†Œè¡¨: ok={ok} fail={fail}")
    return 0

def cmd_clear(args):
    """ä¸€é”®æ¸…é™¤æ‰€æœ‰ CLI/IDE çš„ MCP é…ç½®ã€‚"""
    targets = []
    which = getattr(args,'client',None) or 'all'
    if which == 'all':
        targets = ['claude','codex','gemini','iflow','droid','cursor','vscode-user','vscode-insiders']
    else:
        targets = [which]

    if not getattr(args,'yes',False):
        tag = ', '.join(targets)
        try:
            reply = 'y' if os.environ.get('MCP_CLEAR_YES') == '1' else input(f"å°†æ¸…ç©ºä»¥ä¸‹å®¢æˆ·ç«¯çš„ MCP é…ç½® [{tag}]ï¼Œç¡®è®¤? [y/N]: ").strip().lower()
        except EOFError:
            reply = 'n'
        if reply != 'y':
            print('å·²å–æ¶ˆ')
            return 0

    for t in targets:
        try:
            if t == 'claude':
                _clear_json_map('Claude(æ–‡ä»¶)', HOME/'.claude'/'settings.json', 'mcpServers')
                _clear_claude_registry(verbose=getattr(args,'verbose',False))
            elif t == 'codex':
                p = HOME/'.codex'/'config.toml'
                if DRY_RUN:
                    print(f"[DRY-RUN] å°†æ¸…ç† Codex é…ç½®: {p}")
                else:
                    if not p.exists():
                        print(f"[INFO] è·³è¿‡ Codexï¼ˆé…ç½®ä¸å­˜åœ¨ï¼‰: {p}")
                    else:
                        backup(p)
                        text = p.read_text(encoding='utf-8')
                        new_text = _strip_toml_mcp_servers_block(text)
                        p.write_text(new_text, encoding='utf-8')
                        print(f"[OK] å·²æ¸…ç©º Codex: {p}")
            elif t == 'gemini':
                _clear_json_map('Gemini', HOME/'.gemini'/'settings.json', 'mcpServers', extra='gemini.allowed')
            elif t == 'iflow':
                _clear_json_map('iFlow', HOME/'.iflow'/'settings.json', 'mcpServers')
            elif t == 'droid':
                _clear_json_map('Droid', HOME/'.factory'/'mcp.json', 'mcpServers')
            elif t == 'cursor':
                _clear_json_map('Cursor', HOME/'.cursor'/'mcp.json', 'mcpServers')
            elif t == 'vscode-user':
                _clear_json_map('VS Code(User)', _vscode_user_path(), 'servers')
            elif t == 'vscode-insiders':
                _clear_json_map('VS Code(Insiders)', _vscode_insiders_path(), 'servers')
        except Exception as e:
            print(f"[WARN] æ¸…ç† {t} å¤±è´¥: {e}")
    print('[OK] æ¸…ç†å®Œæˆ')
    return 0

def apply_json_map(label, path: Path, subset: dict, top_key='mcpServers'):
    obj = load_json(path, {})
    keys = sorted(list((subset or {}).keys()))
    if DRY_RUN:
        print(f"[DRY-RUN] å°†åº”ç”¨åˆ° {label}: {path}")
        print("  keys:", ', '.join(keys) if keys else '(none)')
        return 0
    
    # Droid: å†™å…¥ ~/.factory/mcp.json é¡¶å±‚ mcpServersï¼ˆå®˜æ–¹æ ¼å¼ï¼‰
    if label == 'Droid':
        # åªä¿ç•™æ ‡å‡†æ ¼å¼
        obj = {}
        servers_config = {}
        for name, info in subset.items():
            server_config = {}
            if 'command' in info:
                server_config['command'] = info['command']
            if 'args' in info:
                server_config['args'] = info['args']
            if 'env' in info and info['env']:
                server_config['env'] = info['env']
            # æ˜¾å¼ stdioï¼Œå…¼å®¹ Bridge/CLI æ–‡æ¡£
            server_config['type'] = 'stdio'
            servers_config[name] = server_config
        obj['mcpServers'] = servers_config
    elif top_key == 'servers':
        obj['servers'] = subset
    else:
        obj[top_key] = subset
        if label == 'Gemini':
            obj.setdefault('mcp', {})['allowed'] = sorted(subset.keys())
    
    backup(path)
    save_json(path, obj)
    print(f"[OK] å·²åº”ç”¨åˆ° {label}: {path}")
    return 0

def apply_claude(subset, verbose: bool=False):
    # æ–‡ä»¶ç«¯
    apply_json_map('Claude(æ–‡ä»¶)', HOME/'.claude'/'settings.json', subset, 'mcpServers')
    # æ³¨å†Œè¡¨ç«¯ï¼šç§»é™¤å¤šä½™ï¼Œè¡¥é½ç¼ºå¤±
    if DRY_RUN:
        # ä»…é¢„è§ˆå°†è¦æ‰§è¡Œçš„æ³¨å†Œè¡¨å‘½ä»¤ï¼Œä¸å®é™…è°ƒç”¨ `claude mcp`
        obj,_ = load_central_servers()
        servers = obj.get('servers') or {}
        want = sorted(subset.keys())
        print('[DRY-RUN] å°†å¯¹é½ Claude æ³¨å†Œè¡¨ï¼ˆé¢„è§ˆï¼‰')
        print('  keys:', ', '.join(want) if want else '(none)')
        for n in want:
            info = servers.get(n) or {}
            cmd = ['claude','mcp','add','--transport','stdio', n]
            for k,v in (info.get('env') or {}).items():
                cmd += ['-e', f'{k}={v}']
            cmd += ['--', _expand_tilde(info.get('command',''))]
            cmd += [ _expand_tilde(str(a)) for a in (info.get('args') or []) ]
            # æ€»æ˜¯è¾“å‡ºå°†è¦æ‰§è¡Œçš„å‘½ä»¤ï¼ˆç®€æ´é¢„è§ˆï¼‰ï¼Œè¯¦ç»†æ ‡è®°ç”± -v æ§åˆ¶
            print('[DRY-RUN]', ' '.join(cmd))
        print('  æ³¨ï¼šdry-run ä¸ä¼šæ‰§è¡Œ `claude mcp list/remove/add`')
        return 0
    try:
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=30)
        have=set()
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        for line in text.splitlines():
            if ':' in line:
                have.add(line.split(':',1)[0].strip())
    except Exception:
        have=set()
    want=set(subset.keys())
    # å…ˆç§»é™¤å¤šä½™
    remove_ok=[]; remove_fail=[]
    for n in sorted(have-want):
        try:
            cmd_rm = ['claude','mcp','remove',n]
            if verbose:
                print('[VERBOSE]', ' '.join(cmd_rm))
            r = subprocess.run(cmd_rm, check=False, timeout=10)
            (remove_ok if r.returncode==0 else remove_fail).append(n)
        except Exception:
            remove_fail.append(n)
    # å†â€œå¼ºåˆ¶é‡æ³¨å†Œâ€ç›®æ ‡é›†åˆï¼Œç¡®ä¿å‘½ä»¤/å‚æ•°ä¸ä¸­å¤®æ¸…å•ä¸€è‡´
    obj,_ = load_central_servers()
    servers = obj.get('servers') or {}
    add_ok=[]; add_fail=[]
    for n in sorted(want):
        info = servers.get(n) or {}
        # å…ˆå°è¯•ç§»é™¤æ—§è®°å½•ï¼Œå¿½ç•¥é”™è¯¯
        try:
            subprocess.run(['claude','mcp','remove',n], check=False, timeout=10)
        except Exception:
            pass
        # é‡æ–°æ·»åŠ ä¸º stdio + ä¸­å¤®æ¸…å•å‘½ä»¤
        cmd = ['claude','mcp','add','--transport','stdio', n]
        for k,v in (info.get('env') or {}).items():
            cmd += ['-e', f'{k}={v}']
        # å±•å¼€è·¯å¾„
        cmd += ['--', _expand_tilde(info.get('command',''))]
        cmd += [ _expand_tilde(str(a)) for a in (info.get('args') or []) ]
        try:
            if verbose:
                print('[VERBOSE]', ' '.join(cmd))
            r = subprocess.run(cmd, check=False, timeout=45)
            (add_ok if r.returncode==0 else add_fail).append(n)
        except Exception:
            add_fail.append(n)
    # æ±‡æ€»
    total_add = len(add_ok)+len(add_fail)
    total_rm = len(remove_ok)+len(remove_fail)
    print('[OK] Claude æ³¨å†Œè¡¨å·²ä¸æ‰€é€‰é›†åˆå¯¹é½')
    if total_rm:
        print(f"  remove: ok={len(remove_ok)} fail={len(remove_fail)}" + (f"; failed=[{', '.join(remove_fail)}]" if remove_fail else ''))
    if total_add:
        print(f"  add   : ok={len(add_ok)} fail={len(add_fail)}" + (f"; failed=[{', '.join(add_fail)}]" if add_fail else ''))
    return 0

def cmd_pick(args):
    # ç®€æ˜“äº¤äº’ï¼šæ•°å­—é€‰æ‹©å®¢æˆ·ç«¯ + å¤šé€‰æœåŠ¡
    clients = [
        ('claude','Claude CLI'),
        ('codex','Codex CLI'),
        ('gemini','Gemini'),
        ('iflow','iFlow'),
        ('droid','Droid CLI'),
        ('cursor','Cursor'),
        ('vscode-user','VS Code(User)'),
        ('vscode-insiders','VS Code(Insiders)')
    ]
    print('é€‰æ‹©ç›®æ ‡ CLI/IDE:')
    for i,(key,label) in enumerate(clients, start=1):
        print(f'  {i}) {label} [{key}]')
    cidx = int(input('è¾“å…¥ç¼–å·: ').strip() or '1')
    client = clients[cidx-1][0]
    # æœåŠ¡å™¨å¤šé€‰
    _, servers = load_central_servers()
    names = sorted(servers.keys())
    print('\né€‰æ‹©è¦å¯ç”¨çš„ MCPï¼ˆç©ºæ ¼åˆ†éš”ç¼–å·ï¼‰:')
    for i,n in enumerate(names, start=1):
        print(f'  {i:2}) {n}')
    picks = input('è¾“å…¥ç¼–å·åˆ—è¡¨: ').strip().split()
    chosen = []
    for p in picks:
        if p.isdigit() and 1 <= int(p) <= len(names):
            chosen.append(names[int(p)-1])
    if not chosen:
        print('[ERR] æœªé€‰æ‹©ä»»ä½•æœåŠ¡å™¨')
        return 1
    print(f'å°†åº”ç”¨åˆ° {client}:', ', '.join(chosen))
    ok = input('ç¡®è®¤? [y/N]: ').strip().lower() == 'y'
    if not ok:
        print('å·²å–æ¶ˆ')
        return 0
    return cmd_run(argparse.Namespace(client=client, servers=','.join(chosen), exec=[]))

def main():
    p = argparse.ArgumentParser(prog='mcp', description='MCP é…ç½®é›†/å¼€å…³ä¸æŒ‰å®¢æˆ·ç«¯è½åœ°ï¼ˆå·²ç§»é™¤ nvm ç›¸å…³åŠŸèƒ½ï¼‰')
    p.add_argument('-v','--verbose', action='store_true', help='æ˜¾ç¤ºæ›´è¯¦ç»†çš„å‘½ä»¤ä¸æ‰§è¡Œä¿¡æ¯')
    p.add_argument('-n','--dry-run', action='store_true', help='ä»…é¢„è§ˆï¼šä¸å†™å…¥æ–‡ä»¶ã€ä¸è¿è¡Œ `claude mcp`ã€ä¸æ‰§è¡Œç›®æ ‡å‘½ä»¤')
    sub = p.add_subparsers(dest='cmd', required=True)

    sp_st = sub.add_parser('status', help='æŸ¥çœ‹æŒ‰å®¢æˆ·ç«¯/IDE çš„å®é™…å¯ç”¨çŠ¶æ€ï¼›ä¹Ÿå¯ç”¨ï¼šmcp status codex')
    sp_st.add_argument('client_pos', nargs='?', help='å®¢æˆ·ç«¯åˆ«åï¼Œå¦‚ claude/codex/vscode ç­‰')
    sp_st.add_argument('--client', choices=['claude-file','claude-reg','codex','gemini','iflow','droid','cursor','vscode-user','vscode-ins'], help='ä»…æŸ¥çœ‹æŒ‡å®šå®¢æˆ·ç«¯ï¼ˆæ›´ç²¾ç¡®ï¼‰')
    sp_st.add_argument('--central', action='store_true', help='åŒæ—¶æ˜¾ç¤ºä¸­å¤®æ¸…å•è§†å›¾')
    sp_st.set_defaults(func=cmd_status)

    # å·²ç§»é™¤ï¼šon/off/only

    # å·²ç§»é™¤ï¼šprofile-save / profile-apply
    # ï¼ˆå·²ç§»é™¤ apply-cli å­å‘½ä»¤ï¼‰

    sp_pick = sub.add_parser('pick', help='äº¤äº’å¼é€‰æ‹©ç›®æ ‡ CLI ä¸æœåŠ¡å™¨é›†åˆå¹¶åº”ç”¨')
    sp_pick.add_argument('-v','--verbose', action='store_true', help='æ˜¾ç¤ºæ›´è¯¦ç»†çš„å‘½ä»¤ä¸æ‰§è¡Œä¿¡æ¯ï¼ˆä»…éƒ¨åˆ† client ç”Ÿæ•ˆï¼‰')
    sp_pick.set_defaults(func=cmd_pick)

    # å·²ç§»é™¤ï¼šsyncï¼ˆå…¨é‡åŒæ­¥ï¼‰
    sp_run = sub.add_parser('run', help='æŒ‰å®¢æˆ·ç«¯åº”ç”¨é›†åˆåå¯åŠ¨å‘½ä»¤ï¼Œä¾‹å¦‚ï¼šmcp run --client claude --servers context7,serena -- claude')
    sp_run.add_argument('--client', required=True, choices=['claude','codex','gemini','iflow','droid','cursor','vscode-user','vscode-insiders'])
    sp_run.add_argument('--servers', required=True, help='ä»¥é€—å·åˆ†éš”çš„æœåŠ¡å™¨å')
    sp_run.add_argument('exec', nargs=argparse.REMAINDER, help='åœ¨ -- ä¹‹åçš„å¯åŠ¨å‘½ä»¤')
    sp_run.set_defaults(func=cmd_run)
    sub.add_parser('check', help='åªè¯»ä½“æ£€').set_defaults(func=cmd_check)

    # æ–°å¢ï¼šclear ä¸€é”®æ¸…é™¤æ‰€æœ‰ CLI/IDE çš„ MCP é…ç½®
    sp_clear = sub.add_parser('clear', help='ä¸€é”®æ¸…é™¤æ‰€æœ‰ CLI/IDE çš„ MCP é…ç½®ï¼ˆæ”¯æŒ --client å®šå‘ï¼‰')
    sp_clear.add_argument('--client', choices=['claude','codex','gemini','iflow','droid','cursor','vscode-user','vscode-insiders','all'], default='all', help='æŒ‡å®šä»…æ¸…ç†æŸä¸ªå®¢æˆ·ç«¯ï¼Œé»˜è®¤ all')
    sp_clear.add_argument('-y','--yes', action='store_true', help='è·³è¿‡ç¡®è®¤')
    sp_clear.add_argument('-v','--verbose', action='store_true', help='æ˜¾ç¤ºæ›´è¯¦ç»†çš„æ‰§è¡Œä¿¡æ¯')
    sp_clear.set_defaults(func=cmd_clear)

    args = p.parse_args()
    global DRY_RUN
    DRY_RUN = bool(getattr(args, 'dry_run', False))
    rc = args.func(args)
    if isinstance(rc, int):
        sys.exit(rc)

if __name__ == '__main__':
    main()
