#!/usr/bin/env python3
from __future__ import annotations
# mcp: è½»é‡å‘½ä»¤è¡Œï¼Œç”¨äºæŒ‰éœ€å¯ç”¨/ç¦ç”¨ MCP æœåŠ¡å™¨ã€åº”ç”¨é…ç½®é›†(profile)ï¼Œ
#      å¹¶å°†æ‰€é€‰é›†åˆè½åœ°åˆ°æŒ‡å®š CLI/IDEï¼ˆä¸å†æä¾› nvm ç›¸å…³åˆ‡æ¢ï¼‰ã€‚

import argparse, json, os, re, shutil, subprocess, sys, platform
from pathlib import Path

# Import validation module with graceful fallback
try:
    from mcp_validation import (
        validate_mcp_servers_config, 
        MCPValidationError, 
        MCPSchemaError, 
        MCPConfigError,
        format_validation_error
    )
    VALIDATION_AVAILABLE = True
except ImportError:
    # Fallback when validation module is not available
    VALIDATION_AVAILABLE = False
    def validate_mcp_servers_config(config_path): return {}
    class MCPValidationError(Exception): pass
    class MCPSchemaError(Exception): pass
    class MCPConfigError(Exception): pass
    def format_validation_error(error): return f"âŒ é…ç½®é”™è¯¯: {str(error)}"

HOME = Path.home()
CENTRAL = HOME/'.mcp-central'/'config'/'mcp-servers.json'

# å…¨å±€å¼€å…³ï¼šdry-runï¼ˆä»…é¢„è§ˆï¼Œä¸è½åœ°ï¼‰
DRY_RUN = False

def load_json(p: Path, default, error_context: str = ""):
    """Load JSON file with enhanced error handling.
    
    Args:
        p: Path to the JSON file
        default: Default value to return on error
        error_context: Additional context for error messages
        
    Returns:
        Parsed JSON object or default value
    """
    if not p.exists():
        return default
    try:
        content = p.read_text(encoding='utf-8')
        if not content.strip():
            if error_context:
                print(f"âš ï¸ è­¦å‘Š: {error_context} - æ–‡ä»¶ä¸ºç©º: {p}", file=sys.stderr)
            return default
        return json.loads(content)
    except json.JSONDecodeError as e:
        if error_context:
            print(f"âŒ {error_context} - JSON è§£æé”™è¯¯: {p}", file=sys.stderr)
            print(f"   é”™è¯¯ä½ç½®: è¡Œ {e.lineno}, åˆ— {e.colno}", file=sys.stderr)
            if e.msg:
                print(f"   é”™è¯¯ä¿¡æ¯: {e.msg}", file=sys.stderr)
        return default
    except Exception as e:
        if error_context:
            print(f"âŒ {error_context} - è¯»å–æ–‡ä»¶å¤±è´¥: {p}", file=sys.stderr)
            print(f"   é”™è¯¯ä¿¡æ¯: {e}", file=sys.stderr)
        return default

def save_json(p: Path, obj: dict):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding='utf-8')

def backup(p: Path):
    if not p.exists():
        return None
    ts = __import__('datetime').datetime.now().strftime('%Y%m%d_%H%M%S')
    b = p.with_suffix(f'.{ts}.backup')
    shutil.copy2(p, b)
    return b

def load_central_servers():
    """Load central MCP servers configuration with validation.
    
    Returns:
        tuple: (config_dict, servers_dict)
    """
    # First try to validate the configuration
    validation_passed = False
    obj = {}
    
    if VALIDATION_AVAILABLE and CENTRAL.exists():
        try:
            obj = validate_mcp_servers_config(CENTRAL)
            validation_passed = True
            print("âœ… ä¸­å¤®é…ç½®å·²é€šè¿‡ schema éªŒè¯", file=sys.stderr) if getattr(load_central_servers, '_verbose', False) else None
        except (MCPValidationError, MCPSchemaError) as e:
            print(format_validation_error(e), file=sys.stderr)
            print("âš ï¸  è­¦å‘Š: Schema éªŒè¯å¤±è´¥ï¼Œä½¿ç”¨åŸºæœ¬ JSON è§£æï¼ˆåŠŸèƒ½å¯èƒ½å—é™ï¼‰", file=sys.stderr)
            # Fall back to basic JSON loading
            obj = load_json(CENTRAL, {}, "ä¸­å¤®é…ç½®éªŒè¯å¤±è´¥")
        except Exception as e:
            print(f"âŒ éªŒè¯è¿‡ç¨‹å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}", file=sys.stderr)
            print("âš ï¸  è­¦å‘Š: ä½¿ç”¨åŸºæœ¬ JSON è§£æ", file=sys.stderr)
            obj = load_json(CENTRAL, {}, "ä¸­å¤®é…ç½®éªŒè¯å¼‚å¸¸")
    else:
        # Validation not available, use basic loading
        obj = load_json(CENTRAL, {}, "ä¸­å¤®é…ç½®åŠ è½½")
    
    # Extract servers with error handling
    servers = obj.get('servers') or {}
    if not isinstance(servers, dict):
        print("âŒ é”™è¯¯: 'servers' å­—æ®µå¿…é¡»æ˜¯å¯¹è±¡æ ¼å¼", file=sys.stderr)
        servers = {}
    
    # Validate individual servers if validation is available
    if VALIDATION_AVAILABLE and validation_passed:
        from mcp_validation import validate_server_config
        for server_name, server_info in servers.items():
            try:
                validate_server_config(server_name, server_info)
            except MCPValidationError as e:
                print(f"âš ï¸  æœåŠ¡å™¨é…ç½®è­¦å‘Š - {server_name}: {e}", file=sys.stderr)
    
    return obj, servers

def write_central_servers(obj):
    backup(CENTRAL)
    save_json(CENTRAL, obj)

# æ³¨ï¼šå·²ç§»é™¤ nvm ä¸ä¸­å¤®æ¸…å•å¼€å…³æ§åˆ¶é€»è¾‘

def list_servers():
    obj, servers = load_central_servers()
    rows = []
    for n, v in sorted(servers.items()):
        en = bool(v.get('enabled', True))
        cmd = v.get('command','')
        rows.append((n, 'on' if en else 'off', cmd))
    print("ä¸­å¤®æ¸…å•ï¼ˆå¯ç”¨å¼€å…³ä¸å‘½ä»¤è·¯å¾„ï¼‰")
    print("name                        state  command")
    print("-"*60)
    for n,st,cmd in rows:
        print(f"{n:26} {st:5}  {cmd}")

def _json_keys(path: Path, pref_key='mcpServers', error_context: str = ""):
    """Extract keys from JSON file with error handling.
    
    Args:
        path: Path to the JSON file
        pref_key: Preferred key to look for
        error_context: Context for error messages
        
    Returns:
        set: Set of keys found
    """
    obj = load_json(path, {}, error_context or f"è¯»å– {path.name} é…ç½®")
    if isinstance(obj.get(pref_key), dict):
        return set(obj[pref_key].keys())
    if isinstance(obj.get('servers'), dict):
        return set(obj['servers'].keys())
    return set()

def _codex_keys():
    p = HOME/'.codex'/'config.toml'
    if not p.exists():
        return set()
    try:
        import tomllib
        conf = tomllib.loads(p.read_text(encoding='utf-8'))
        m = conf.get('mcp_servers', {}) or {}
        return {k for k in m.keys() if not k.endswith('.env')}
    except Exception:
        # ç®€æ˜“å›é€€ï¼šæ­£åˆ™æå– [mcp_servers.NAME] æ®µ
        import re
        names = set()
        for line in p.read_text(encoding='utf-8').splitlines():
            line = line.strip()
            m = re.match(r"^\[mcp_servers\.([^\]]+)\]$", line)
            if m:
                name = m.group(1)
                if not name.endswith('.env'):
                    names.add(name)
        return names

def _claude_registered():
    """æ›´ç¨³å¥åœ°è¯»å– Claude æ³¨å†Œè¡¨ã€‚
    - å»¶é•¿è¶…æ—¶ï¼ˆ30sï¼‰ï¼Œé€‚é…â€œClaude Code æ™ºèƒ½å¯åŠ¨â€çš„ç½‘ç»œæ¢æµ‹
    - åˆå¹¶ stdout+stderr è§£æï¼Œé¿å…åªè¯» stdout æ¼é¡¹
    """
    try:
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=30)
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        reg = set()
        for line in text.splitlines():
            if ':' in line:
                reg.add(line.split(':',1)[0].strip())
        return reg
    except Exception:
        return set()

def _print_client(label, present, universe):
    present = sorted(present)
    absent = sorted(set(universe) - set(present))
    print(f"\n[{label}]")
    print("  on : "+ (', '.join(present) if present else 'æ— '))
    print("  off: "+ (', '.join(absent) if absent else 'æ— '))

def _normalize_client(alias: str|None):
    if not alias:
        return None
    a = alias.strip().lower()
    mapping = {
        'claude': 'claude-file',
        'claude-file': 'claude-file',
        'claude-reg': 'claude-reg',
        'codex': 'codex',
        'gemini': 'gemini',
        'iflow': 'iflow',
        'droid': 'droid',
        'cursor': 'cursor',
        'vscode': 'vscode-user',
        'vscode-user': 'vscode-user',
        'vscode-insiders': 'vscode-ins',
        'vscode-ins': 'vscode-ins',
        'insiders': 'vscode-ins',
    }
    return mapping.get(a)

def _expand_tilde(v):
    if isinstance(v, str):
        try:
            return os.path.expanduser(v)
        except Exception:
            return v
    return v

def _expand_entry(entry: dict):
    if not isinstance(entry, dict):
        return entry
    e = dict(entry)
    if 'command' in e:
        e['command'] = _expand_tilde(e['command'])
    if 'args' in e and isinstance(e['args'], list):
        e['args'] = [_expand_tilde(a) for a in e['args']]
    return e

def cmd_status(args):
    """æ˜¾ç¤º MCP æœåŠ¡å™¨çŠ¶æ€ï¼ŒåŒ…æ‹¬ä¸­å¤®é…ç½®å’Œå„å®¢æˆ·ç«¯çš„å®é™…å¯ç”¨çŠ¶æ€"""
    try:
        obj, servers = load_central_servers()
    except Exception as e:
        print(f"âŒ åŠ è½½ä¸­å¤®é…ç½®å¤±è´¥: {e}", file=sys.stderr)
        print("âš ï¸  å°è¯•ä½¿ç”¨é»˜è®¤é…ç½®ç»§ç»­...", file=sys.stderr)
        servers = {}
        obj = {}
    
    central_names = sorted(servers.keys())
    print(f"ğŸ“Š ä¸­å¤®é…ç½®ä¸­çš„æœåŠ¡å™¨æ•°é‡: {len(central_names)}", file=sys.stderr)
    
    # å¯é€‰æ˜¾ç¤ºä¸­å¤®æ¸…å•
    if args.central:
        list_servers()
    
    # å®¢æˆ·ç«¯/IDE è§†å›¾ï¼ˆå¯é€‰è¿‡æ»¤ï¼‰
    # å…è®¸ä½ç½®å‚æ•° client_pos æˆ– --clientï¼›å¹¶æ”¯æŒç®€å†™åˆ«å
    sel = _normalize_client(getattr(args, 'client_pos', None)) or _normalize_client(args.client)
    targets = [
        ('claude-file', 'Claude(file)', lambda: _json_keys(HOME/'.claude'/'settings.json', 'mcpServers', 'Claudeé…ç½®è¯»å–')),
        ('claude-reg',  'Claude(register)', _claude_registered),
        ('codex',       'Codex', _codex_keys),
        ('gemini',      'Gemini', lambda: _json_keys(HOME/'.gemini'/'settings.json', 'mcpServers', 'Geminié…ç½®è¯»å–')),
        ('iflow',       'iFlow', lambda: _json_keys(HOME/'.iflow'/'settings.json', 'mcpServers', 'iFlowé…ç½®è¯»å–')),
        ('droid',       'Droid', lambda: _json_keys(HOME/'.factory'/'mcp.json', 'mcpServers', 'Droidé…ç½®è¯»å–')),
        ('cursor',      'Cursor', lambda: _json_keys(HOME/'.cursor'/'mcp.json', 'mcpServers', 'Cursoré…ç½®è¯»å–')),
        ('vscode-user', 'VS Code(User)', lambda: _json_keys(HOME/'.config'/'Code'/'User'/'mcp.json', 'servers', 'VS Codeé…ç½®è¯»å–')),
        ('vscode-ins',  'VS Code(Insiders)', lambda: _json_keys(HOME/'.config'/'Code - Insiders'/'User'/'mcp.json', 'servers', 'VS Code Insidersé…ç½®è¯»å–')),
    ]
    print("â€” æŒ‰å®¢æˆ·ç«¯/IDE çš„å®é™…å¯ç”¨è§†å›¾ â€”")
    for key, label, fn in targets:
        if sel and sel != key:
            continue
        try:
            present = fn()
            if args.verbose:
                print(f"ğŸ” {label}: æ‰¾åˆ° {len(present)} ä¸ªå·²é…ç½®æœåŠ¡å™¨", file=sys.stderr)
        except Exception as e:
            if args.verbose:
                print(f"âš ï¸  {label}: è¯»å–é…ç½®æ—¶å‡ºé”™ - {e}", file=sys.stderr)
            present = set()
        _print_client(label, present, central_names)

def ide_clients():
    return ['cursor','vscode-user','vscode-ins']

def cmd_ide_all(args):
    # ä¿æŠ¤ï¼šé»˜è®¤ç¡®è®¤ï¼Œé¿å…è¯¯è¦†ç›–â€œè£¸å¥”ç­–ç•¥â€ï¼›dry-run æ—¶è·³è¿‡äº¤äº’ï¼Œä»…åšé¢„è§ˆ
    if not DRY_RUN:
        if not getattr(args, 'yes', False):
            try:
                resp = input('å°†æŠŠå…¨éƒ¨ MCP å†™å…¥ VS Code/Cursorï¼Œå¯èƒ½è¦†ç›–å½“å‰æœ€å°è½åœ°ç­–ç•¥ã€‚ç»§ç»­ï¼Ÿ[y/N]: ').strip().lower()
            except EOFError:
                resp = 'n'
            if resp != 'y':
                print('å·²å–æ¶ˆ')
                return 0
    obj, servers = load_central_servers()
    subset = {n: servers[n] for n in servers.keys()}  # å¿½ç•¥ enabledï¼Œå…¨éƒ¨å†™å…¥
    # Cursor
    apply_json_map('Cursor', HOME/'.cursor'/'mcp.json', subset, 'mcpServers')
    # VS Code(User/Insiders) è·¯å¾„æŒ‰ç³»ç»Ÿé€‚é…
    os_name = platform.system().lower()
    if os_name == 'darwin':
        vsc_user = HOME/'Library'/'Application Support'/'Code'/'User'/'mcp.json'
        vsc_ins = HOME/'Library'/'Application Support'/'Code - Insiders'/'User'/'mcp.json'
    else:
        vsc_user = HOME/'.config'/'Code'/'User'/'mcp.json'
        vsc_ins = HOME/'.config'/'Code - Insiders'/'User'/'mcp.json'
    apply_json_map('VS Code(User)', vsc_user, subset, 'servers')
    apply_json_map('VS Code(Insiders)', vsc_ins, subset, 'servers')
    if DRY_RUN:
        print('[DRY-RUN] ä»¥ä¸Šä¸ºå°†å†™å…¥ IDE çš„é¢„è§ˆï¼›æœªè¿›è¡Œå®é™…å†™å…¥ã€‚')
    else:
        print('[OK] å·²å°†å…¨éƒ¨ MCP å†™å…¥ IDEï¼ˆCursor/VS Codeï¼‰')
    return 0

def cmd_run(args):
    # å…ˆåº”ç”¨åˆ°æŒ‡å®šå®¢æˆ·ç«¯
    rc = cmd_apply_cli(argparse.Namespace(client=args.client, servers=args.servers))
    if isinstance(rc, int) and rc != 0:
        return rc
    # æ‰§è¡Œå‘½ä»¤
    exec_cmd = args.exec or []
    while exec_cmd and exec_cmd[0] == '--':
        exec_cmd.pop(0)
    if not exec_cmd:
        # é»˜è®¤æ˜ å°„ï¼šclaude -> ['claude']
        if args.client.startswith('claude'):
            exec_cmd = ['claude']
        elif args.client == 'codex':
            exec_cmd = ['codex']
    if not exec_cmd:
        print('[OK] å·²åº”ç”¨æ‰€é€‰é›†åˆï¼›æœªæä¾›å¯åŠ¨å‘½ä»¤ï¼Œç»“æŸã€‚')
        return 0
    if DRY_RUN:
        print('[DRY-RUN] å°†æ‰§è¡Œå‘½ä»¤ï¼ˆé¢„è§ˆï¼‰ï¼š', ' '.join(exec_cmd))
        return 0
    os.execvp(exec_cmd[0], exec_cmd)

## å·²ç§»é™¤ï¼šcmd_on/cmd_off/cmd_onlyï¼ˆä¸­å¤®æ¸…å•å¼€å…³ä¸å†ä½œä¸ºå…¥å£ï¼‰

## å·²ç§»é™¤ï¼šcmd_enable_allï¼ˆé»˜è®¤è§†ä¸ºå…¨éƒ¨å¯ç”¨ï¼‰

 

def cmd_sync(args):
    here = Path(__file__).resolve().parent.parent
    sync_py = here/'bin'/'mcp-auto-sync.py'
    rc = subprocess.call([sys.executable, str(sync_py), 'sync'])
    sys.exit(rc)

def cmd_check(args):
    here = Path(__file__).resolve().parent.parent
    script = here/'scripts'/'mcp-check.sh'
    rc = subprocess.call(['bash', str(script)])
    sys.exit(rc)

def build_subset(names):
    obj, servers = load_central_servers()
    sel = {}
    for n in names:
        if n in servers:
            sel[n] = servers[n]
    return sel

def apply_codex(subset):
    p = HOME/'.codex'/'config.toml'
    if not p.exists():
        print(f"[ERR] Codex é…ç½®ä¸å­˜åœ¨: {p}")
        return 1
    keys = sorted(list(subset.keys()))
    if DRY_RUN:
        print(f"[DRY-RUN] å°†åº”ç”¨åˆ° Codex: {p}")
        print("  keys:", ', '.join(keys) if keys else '(none)')
        return 0
    backup(p)
    text = p.read_text(encoding='utf-8')
    # æ¸…ç†æ—§å— + æ‰€æœ‰ [mcp_servers.*]
    text = re.sub(r"\n*# === MCP Servers é…ç½®ï¼ˆç”± MCP (?:Local Manager|Central) ç”Ÿæˆï¼‰===\n(?:.|\n)*?(?=\n?# ===|\Z)", "\n", text)
    text = re.sub(r"(?ms)^\[mcp_servers\.[^\]]+\][\s\S]*?(?=^\[|\Z)", "", text)
    lines = ["\n# === MCP Servers é…ç½®ï¼ˆç”± MCP Local Manager ç”Ÿæˆï¼‰==="]
    for name,info in subset.items():
        lines.append(f"\n[mcp_servers.{name}]")
        # Codex: å¢åŠ å¯åŠ¨è¶…æ—¶ï¼Œé¿å…é»˜è®¤ 10s è¶…æ—¶ï¼ˆnpx é¦–æ¬¡æ‹‰å–è¾ƒæ…¢ï¼‰
        lines.append("startup_timeout_sec = 60")
        lines.append(f"command = \"{info.get('command','')}\"")
        args = info.get('args') or []
        if args:
            lines.append('args = ' + json.dumps(args))
        env = info.get('env') or {}
        if env:
            lines.append(f"\n[mcp_servers.{name}.env]")
            for k,v in env.items():
                lines.append(f"{k} = \"{v}\"")
    new_block='\n'.join(lines)+"\n"
    p.write_text(text.rstrip()+"\n"+new_block, encoding='utf-8')
    print(f"[OK] å·²åº”ç”¨åˆ° Codex: {p}")
    return 0

def apply_json_map(label, path: Path, subset: dict, top_key='mcpServers'):
    obj = load_json(path, {})
    keys = sorted(list((subset or {}).keys()))
    if DRY_RUN:
        print(f"[DRY-RUN] å°†åº”ç”¨åˆ° {label}: {path}")
        print("  keys:", ', '.join(keys) if keys else '(none)')
        return 0
    if top_key == 'servers':
        obj['servers'] = subset
    else:
        obj[top_key] = subset
        if label == 'Gemini':
            obj.setdefault('mcp', {})['allowed'] = sorted(subset.keys())
    backup(path)
    save_json(path, obj)
    print(f"[OK] å·²åº”ç”¨åˆ° {label}: {path}")
    return 0

def apply_claude(subset, verbose: bool=False):
    # æ–‡ä»¶ç«¯
    apply_json_map('Claude(æ–‡ä»¶)', HOME/'.claude'/'settings.json', subset, 'mcpServers')
    # æ³¨å†Œè¡¨ç«¯ï¼šç§»é™¤å¤šä½™ï¼Œè¡¥é½ç¼ºå¤±
    if DRY_RUN:
        # ä»…é¢„è§ˆå°†è¦æ‰§è¡Œçš„æ³¨å†Œè¡¨å‘½ä»¤ï¼Œä¸å®é™…è°ƒç”¨ `claude mcp`
        obj,_ = load_central_servers()
        servers = obj.get('servers') or {}
        want = sorted(subset.keys())
        print('[DRY-RUN] å°†å¯¹é½ Claude æ³¨å†Œè¡¨ï¼ˆé¢„è§ˆï¼‰')
        print('  keys:', ', '.join(want) if want else '(none)')
        for n in want:
            info = servers.get(n) or {}
            cmd = ['claude','mcp','add','--transport','stdio', n]
            for k,v in (info.get('env') or {}).items():
                cmd += ['-e', f'{k}={v}']
            cmd += ['--', _expand_tilde(info.get('command',''))]
            cmd += [ _expand_tilde(str(a)) for a in (info.get('args') or []) ]
            # æ€»æ˜¯è¾“å‡ºå°†è¦æ‰§è¡Œçš„å‘½ä»¤ï¼ˆç®€æ´é¢„è§ˆï¼‰ï¼Œè¯¦ç»†æ ‡è®°ç”± -v æ§åˆ¶
            print('[DRY-RUN]', ' '.join(cmd))
        print('  æ³¨ï¼šdry-run ä¸ä¼šæ‰§è¡Œ `claude mcp list/remove/add`')
        return 0
    try:
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=30)
        have=set()
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        for line in text.splitlines():
            if ':' in line:
                have.add(line.split(':',1)[0].strip())
    except Exception:
        have=set()
    want=set(subset.keys())
    # å…ˆç§»é™¤å¤šä½™
    remove_ok=[]; remove_fail=[]
    for n in sorted(have-want):
        try:
            cmd_rm = ['claude','mcp','remove',n]
            if verbose:
                print('[VERBOSE]', ' '.join(cmd_rm))
            r = subprocess.run(cmd_rm, check=False, timeout=10)
            (remove_ok if r.returncode==0 else remove_fail).append(n)
        except Exception:
            remove_fail.append(n)
    # å†â€œå¼ºåˆ¶é‡æ³¨å†Œâ€ç›®æ ‡é›†åˆï¼Œç¡®ä¿å‘½ä»¤/å‚æ•°ä¸ä¸­å¤®æ¸…å•ä¸€è‡´
    obj,_ = load_central_servers()
    servers = obj.get('servers') or {}
    add_ok=[]; add_fail=[]
    for n in sorted(want):
        info = servers.get(n) or {}
        # å…ˆå°è¯•ç§»é™¤æ—§è®°å½•ï¼Œå¿½ç•¥é”™è¯¯
        try:
            subprocess.run(['claude','mcp','remove',n], check=False, timeout=10)
        except Exception:
            pass
        # é‡æ–°æ·»åŠ ä¸º stdio + ä¸­å¤®æ¸…å•å‘½ä»¤
        cmd = ['claude','mcp','add','--transport','stdio', n]
        for k,v in (info.get('env') or {}).items():
            cmd += ['-e', f'{k}={v}']
        # å±•å¼€è·¯å¾„
        cmd += ['--', _expand_tilde(info.get('command',''))]
        cmd += [ _expand_tilde(str(a)) for a in (info.get('args') or []) ]
        try:
            if verbose:
                print('[VERBOSE]', ' '.join(cmd))
            r = subprocess.run(cmd, check=False, timeout=45)
            (add_ok if r.returncode==0 else add_fail).append(n)
        except Exception:
            add_fail.append(n)
    # æ±‡æ€»
    total_add = len(add_ok)+len(add_fail)
    total_rm = len(remove_ok)+len(remove_fail)
    print('[OK] Claude æ³¨å†Œè¡¨å·²ä¸æ‰€é€‰é›†åˆå¯¹é½')
    if total_rm:
        print(f"  remove: ok={len(remove_ok)} fail={len(remove_fail)}" + (f"; failed=[{', '.join(remove_fail)}]" if remove_fail else ''))
    if total_add:
        print(f"  add   : ok={len(add_ok)} fail={len(add_fail)}" + (f"; failed=[{', '.join(add_fail)}]" if add_fail else ''))
    return 0

def cmd_apply_cli(args):
    subset = build_subset(args.servers.split(','))
    if not subset:
        print('[ERR] æœåŠ¡å™¨åæ— æ•ˆæˆ–ä¸ºç©º')
        return 1
    client = args.client
    if client == 'claude':
        return apply_claude(subset, verbose=getattr(args,'verbose',False))
    elif client == 'codex':
        return apply_codex(subset)
    elif client == 'gemini':
        return apply_json_map('Gemini', HOME/'.gemini'/'settings.json', subset, 'mcpServers')
    elif client == 'iflow':
        return apply_json_map('iFlow', HOME/'.iflow'/'settings.json', subset, 'mcpServers')
    elif client == 'droid':
        return apply_json_map('Droid', HOME/'.factory'/'mcp.json', subset, 'mcpServers')
    elif client == 'cursor':
        return apply_json_map('Cursor', HOME/'.cursor'/'mcp.json', subset, 'mcpServers')
    elif client == 'vscode-user':
        return apply_json_map('VS Code(User)', HOME/'.config'/'Code'/'User'/'mcp.json', subset, 'servers')
    elif client == 'vscode-insiders':
        return apply_json_map('VS Code(Insiders)', HOME/'.config'/'Code - Insiders'/'User'/'mcp.json', subset, 'servers')
    else:
        print('[ERR] æœªçŸ¥ client')
        return 2

def cmd_pick(args):
    # ç®€æ˜“äº¤äº’ï¼šæ•°å­—é€‰æ‹©å®¢æˆ·ç«¯ + å¤šé€‰æœåŠ¡
    clients = [
        ('claude','Claude CLI'),
        ('codex','Codex CLI'),
        ('gemini','Gemini'),
        ('iflow','iFlow'),
        ('droid','Droid CLI'),
        ('cursor','Cursor'),
        ('vscode-user','VS Code(User)'),
        ('vscode-insiders','VS Code(Insiders)')
    ]
    print('é€‰æ‹©ç›®æ ‡ CLI/IDE:')
    for i,(key,label) in enumerate(clients, start=1):
        print(f'  {i}) {label} [{key}]')
    cidx = int(input('è¾“å…¥ç¼–å·: ').strip() or '1')
    client = clients[cidx-1][0]
    # æœåŠ¡å™¨å¤šé€‰
    _, servers = load_central_servers()
    names = sorted(servers.keys())
    print('\né€‰æ‹©è¦å¯ç”¨çš„ MCPï¼ˆç©ºæ ¼åˆ†éš”ç¼–å·ï¼‰:')
    for i,n in enumerate(names, start=1):
        print(f'  {i:2}) {n}')
    picks = input('è¾“å…¥ç¼–å·åˆ—è¡¨: ').strip().split()
    chosen = []
    for p in picks:
        if p.isdigit() and 1 <= int(p) <= len(names):
            chosen.append(names[int(p)-1])
    if not chosen:
        print('[ERR] æœªé€‰æ‹©ä»»ä½•æœåŠ¡å™¨')
        return 1
    print(f'å°†åº”ç”¨åˆ° {client}:', ', '.join(chosen))
    ok = input('ç¡®è®¤? [y/N]: ').strip().lower() == 'y'
    if not ok:
        print('å·²å–æ¶ˆ')
        return 0
    return cmd_apply_cli(argparse.Namespace(client=client, servers=','.join(chosen), verbose=getattr(args,'verbose',False)))

def main():
    p = argparse.ArgumentParser(prog='mcp', description='MCP é…ç½®é›†/å¼€å…³ä¸æŒ‰å®¢æˆ·ç«¯è½åœ°ï¼ˆå·²ç§»é™¤ nvm ç›¸å…³åŠŸèƒ½ï¼‰')
    p.add_argument('-v','--verbose', action='store_true', help='æ˜¾ç¤ºæ›´è¯¦ç»†çš„å‘½ä»¤ä¸æ‰§è¡Œä¿¡æ¯')
    p.add_argument('-n','--dry-run', action='store_true', help='ä»…é¢„è§ˆï¼šä¸å†™å…¥æ–‡ä»¶ã€ä¸è¿è¡Œ `claude mcp`ã€ä¸æ‰§è¡Œç›®æ ‡å‘½ä»¤')
    sub = p.add_subparsers(dest='cmd', required=True)

    sp_st = sub.add_parser('status', help='æŸ¥çœ‹æŒ‰å®¢æˆ·ç«¯/IDE çš„å®é™…å¯ç”¨çŠ¶æ€ï¼›ä¹Ÿå¯ç”¨ï¼šmcp status codex')
    sp_st.add_argument('client_pos', nargs='?', help='å®¢æˆ·ç«¯åˆ«åï¼Œå¦‚ claude/codex/vscode ç­‰')
    sp_st.add_argument('--client', choices=['claude-file','claude-reg','codex','gemini','iflow','droid','cursor','vscode-user','vscode-ins'], help='ä»…æŸ¥çœ‹æŒ‡å®šå®¢æˆ·ç«¯ï¼ˆæ›´ç²¾ç¡®ï¼‰')
    sp_st.add_argument('--central', action='store_true', help='åŒæ—¶æ˜¾ç¤ºä¸­å¤®æ¸…å•è§†å›¾')
    sp_st.set_defaults(func=cmd_status)

    # å·²ç§»é™¤ï¼šon/off/only

    # å·²ç§»é™¤ï¼šprofile-save / profile-apply

    # æ–°å¢ï¼šé’ˆå¯¹å•ä¸ªå®¢æˆ·ç«¯/IDE çš„ä¸“ç”¨è½åœ°
    sp_ac = sub.add_parser('apply-cli', help='å°†æ‰€é€‰æœåŠ¡å™¨ä»…åº”ç”¨åˆ°æŒ‡å®š CLI/IDE çš„é…ç½®æ–‡ä»¶')
    sp_ac.add_argument('--client', required=True, choices=['claude','codex','gemini','iflow','droid','cursor','vscode-user','vscode-insiders'])
    sp_ac.add_argument('--servers', required=True, help='ä»¥é€—å·åˆ†éš”çš„æœåŠ¡å™¨åï¼Œå¦‚ context7,serena')
    sp_ac.add_argument('-v','--verbose', action='store_true', help='æ˜¾ç¤ºæ›´è¯¦ç»†çš„å‘½ä»¤ä¸æ‰§è¡Œä¿¡æ¯ï¼ˆä»…éƒ¨åˆ† client ç”Ÿæ•ˆï¼‰')
    sp_ac.set_defaults(func=cmd_apply_cli)

    sp_pick = sub.add_parser('pick', help='äº¤äº’å¼é€‰æ‹©ç›®æ ‡ CLI ä¸æœåŠ¡å™¨é›†åˆå¹¶åº”ç”¨')
    sp_pick.add_argument('-v','--verbose', action='store_true', help='æ˜¾ç¤ºæ›´è¯¦ç»†çš„å‘½ä»¤ä¸æ‰§è¡Œä¿¡æ¯ï¼ˆä»…éƒ¨åˆ† client ç”Ÿæ•ˆï¼‰')
    sp_pick.set_defaults(func=cmd_pick)

    # å·²ç§»é™¤ï¼šsyncï¼ˆå…¨é‡åŒæ­¥ï¼‰
    sp_ide = sub.add_parser('ide-all', help='å°†å…¨éƒ¨ MCP å†™å…¥ IDEï¼ˆCursor/VS Codeï¼‰ï¼Œå¿½ç•¥å¯ç”¨æ ‡è®°')
    sp_ide.add_argument('-y','--yes', action='store_true', help='ä¸è¯¢é—®ç›´æ¥æ‰§è¡Œ')
    sp_ide.set_defaults(func=cmd_ide_all)
    sp_run = sub.add_parser('run', help='æŒ‰å®¢æˆ·ç«¯åº”ç”¨é›†åˆåå¯åŠ¨å‘½ä»¤ï¼Œä¾‹å¦‚ï¼šmcp run --client claude --servers context7,serena -- claude')
    sp_run.add_argument('--client', required=True, choices=['claude','codex','gemini','iflow','droid','cursor','vscode-user','vscode-insiders'])
    sp_run.add_argument('--servers', required=True, help='ä»¥é€—å·åˆ†éš”çš„æœåŠ¡å™¨å')
    sp_run.add_argument('exec', nargs=argparse.REMAINDER, help='åœ¨ -- ä¹‹åçš„å¯åŠ¨å‘½ä»¤')
    sp_run.set_defaults(func=cmd_run)
    sub.add_parser('check', help='åªè¯»ä½“æ£€').set_defaults(func=cmd_check)

    args = p.parse_args()
    global DRY_RUN
    DRY_RUN = bool(getattr(args, 'dry_run', False))
    rc = args.func(args)
    if isinstance(rc, int):
        sys.exit(rc)

if __name__ == '__main__':
    main()
