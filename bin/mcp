#!/usr/bin/env python3
from __future__ import annotations
# mcp: 轻量命令行，用于按需启用/禁用 MCP 服务器、应用配置集(profile)，
#      并将所选集合落地到指定 CLI/IDE（不再提供 nvm 相关切换）。

import argparse, json, os, re, shutil, subprocess, sys, platform
from pathlib import Path

HOME = Path.home()
CENTRAL = HOME/'.mcp-central'/'config'/'mcp-servers.json'

# 全局开关：dry-run（仅预览，不落地）
DRY_RUN = False

def load_json(p: Path, default):
    if not p.exists():
        return default
    try:
        return json.loads(p.read_text(encoding='utf-8'))
    except Exception:
        return default

def save_json(p: Path, obj: dict):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding='utf-8')

def backup(p: Path):
    if not p.exists():
        return None
    ts = __import__('datetime').datetime.now().strftime('%Y%m%d_%H%M%S')
    b = p.with_suffix(f'.{ts}.backup')
    shutil.copy2(p, b)
    return b

def load_central_servers():
    obj = load_json(CENTRAL, {})
    servers = obj.get('servers') or {}
    return obj, servers

def write_central_servers(obj):
    backup(CENTRAL)
    save_json(CENTRAL, obj)

# 注：已移除 nvm 与中央清单开关控制逻辑

def list_servers():
    obj, servers = load_central_servers()
    rows = []
    for n, v in sorted(servers.items()):
        en = bool(v.get('enabled', True))
        cmd = v.get('command','')
        rows.append((n, 'on' if en else 'off', cmd))
    print("中央清单（启用开关与命令路径）")
    print("name                        state  command")
    print("-"*60)
    for n,st,cmd in rows:
        print(f"{n:26} {st:5}  {cmd}")

def _json_keys(path: Path, pref_key='mcpServers'):
    obj = load_json(path, {})
    if isinstance(obj.get(pref_key), dict):
        return set(obj[pref_key].keys())
    if isinstance(obj.get('servers'), dict):
        return set(obj['servers'].keys())
    return set()

def _codex_keys():
    p = HOME/'.codex'/'config.toml'
    if not p.exists():
        return set()
    try:
        import tomllib
        conf = tomllib.loads(p.read_text(encoding='utf-8'))
        m = conf.get('mcp_servers', {}) or {}
        return {k for k in m.keys() if not k.endswith('.env')}
    except Exception:
        # 简易回退：正则提取 [mcp_servers.NAME] 段
        import re
        names = set()
        for line in p.read_text(encoding='utf-8').splitlines():
            line = line.strip()
            m = re.match(r"^\[mcp_servers\.([^\]]+)\]$", line)
            if m:
                name = m.group(1)
                if not name.endswith('.env'):
                    names.add(name)
        return names

def _claude_registered():
    """更稳健地读取 Claude 注册表。
    - 延长超时（30s），适配“Claude Code 智能启动”的网络探测
    - 合并 stdout+stderr 解析，避免只读 stdout 漏项
    """
    try:
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=30)
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        reg = set()
        for line in text.splitlines():
            if ':' in line:
                reg.add(line.split(':',1)[0].strip())
        return reg
    except Exception:
        return set()

def _print_client(label, present, universe):
    present = sorted(present)
    absent = sorted(set(universe) - set(present))
    print(f"\n[{label}]")
    print("  on : "+ (', '.join(present) if present else '无'))
    print("  off: "+ (', '.join(absent) if absent else '无'))

def _normalize_client(alias: str|None):
    if not alias:
        return None
    a = alias.strip().lower()
    mapping = {
        'claude': 'claude-file',
        'claude-file': 'claude-file',
        'claude-reg': 'claude-reg',
        'codex': 'codex',
        'gemini': 'gemini',
        'iflow': 'iflow',
        'droid': 'droid',
        'cursor': 'cursor',
        'vscode': 'vscode-user',
        'vscode-user': 'vscode-user',
        'vscode-insiders': 'vscode-ins',
        'vscode-ins': 'vscode-ins',
        'insiders': 'vscode-ins',
    }
    return mapping.get(a)

def _expand_tilde(v):
    if isinstance(v, str):
        try:
            return os.path.expanduser(v)
        except Exception:
            return v
    return v

def _expand_entry(entry: dict):
    if not isinstance(entry, dict):
        return entry
    e = dict(entry)
    if 'command' in e:
        e['command'] = _expand_tilde(e['command'])
    if 'args' in e and isinstance(e['args'], list):
        e['args'] = [_expand_tilde(a) for a in e['args']]
    return e

def cmd_status(args):
    obj, servers = load_central_servers()
    central_names = sorted(servers.keys())
    # 可选显示中央清单
    if args.central:
        list_servers()
    # 客户端/IDE 视图（可选过滤）
    # 允许位置参数 client_pos 或 --client；并支持简写别名
    sel = _normalize_client(getattr(args, 'client_pos', None)) or _normalize_client(args.client)
    targets = [
        ('claude-file', 'Claude(file)', lambda: _json_keys(HOME/'.claude'/'settings.json', 'mcpServers')),
        ('claude-reg',  'Claude(register)', _claude_registered),
        ('codex',       'Codex', _codex_keys),
        ('gemini',      'Gemini', lambda: _json_keys(HOME/'.gemini'/'settings.json', 'mcpServers')),
        ('iflow',       'iFlow', lambda: _json_keys(HOME/'.iflow'/'settings.json', 'mcpServers')),
        ('droid',       'Droid', lambda: _json_keys(HOME/'.factory'/'mcp.json', 'mcpServers')),
        ('cursor',      'Cursor', lambda: _json_keys(HOME/'.cursor'/'mcp.json', 'mcpServers')),
        ('vscode-user', 'VS Code(User)', lambda: _json_keys(HOME/'.config'/'Code'/'User'/'mcp.json', 'servers')),
        ('vscode-ins',  'VS Code(Insiders)', lambda: _json_keys(HOME/'.config'/'Code - Insiders'/'User'/'mcp.json', 'servers')),
    ]
    print("— 按客户端/IDE 的实际启用视图 —")
    for key, label, fn in targets:
        if sel and sel != key:
            continue
        try:
            present = fn()
        except Exception:
            present = set()
        _print_client(label, present, central_names)

def ide_clients():
    return ['cursor','vscode-user','vscode-ins']

def cmd_ide_all(args):
    # 保护：默认确认，避免误覆盖“裸奔策略”；dry-run 时跳过交互，仅做预览
    if not DRY_RUN:
        if not getattr(args, 'yes', False):
            try:
                resp = input('将把全部 MCP 写入 VS Code/Cursor，可能覆盖当前最小落地策略。继续？[y/N]: ').strip().lower()
            except EOFError:
                resp = 'n'
            if resp != 'y':
                print('已取消')
                return 0
    obj, servers = load_central_servers()
    subset = {n: servers[n] for n in servers.keys()}  # 忽略 enabled，全部写入
    # Cursor
    apply_json_map('Cursor', HOME/'.cursor'/'mcp.json', subset, 'mcpServers')
    # VS Code(User/Insiders) 路径按系统适配
    os_name = platform.system().lower()
    if os_name == 'darwin':
        vsc_user = HOME/'Library'/'Application Support'/'Code'/'User'/'mcp.json'
        vsc_ins = HOME/'Library'/'Application Support'/'Code - Insiders'/'User'/'mcp.json'
    else:
        vsc_user = HOME/'.config'/'Code'/'User'/'mcp.json'
        vsc_ins = HOME/'.config'/'Code - Insiders'/'User'/'mcp.json'
    apply_json_map('VS Code(User)', vsc_user, subset, 'servers')
    apply_json_map('VS Code(Insiders)', vsc_ins, subset, 'servers')
    if DRY_RUN:
        print('[DRY-RUN] 以上为将写入 IDE 的预览；未进行实际写入。')
    else:
        print('[OK] 已将全部 MCP 写入 IDE（Cursor/VS Code）')
    return 0

def cmd_run(args):
    # 先应用到指定客户端
    rc = cmd_apply_cli(argparse.Namespace(client=args.client, servers=args.servers))
    if isinstance(rc, int) and rc != 0:
        return rc
    # 执行命令
    exec_cmd = args.exec or []
    while exec_cmd and exec_cmd[0] == '--':
        exec_cmd.pop(0)
    if not exec_cmd:
        # 默认映射：claude -> ['claude']
        if args.client.startswith('claude'):
            exec_cmd = ['claude']
        elif args.client == 'codex':
            exec_cmd = ['codex']
    if not exec_cmd:
        print('[OK] 已应用所选集合；未提供启动命令，结束。')
        return 0
    if DRY_RUN:
        print('[DRY-RUN] 将执行命令（预览）：', ' '.join(exec_cmd))
        return 0
    os.execvp(exec_cmd[0], exec_cmd)

## 已移除：cmd_on/cmd_off/cmd_only（中央清单开关不再作为入口）

## 已移除：cmd_enable_all（默认视为全部启用）

 

def cmd_sync(args):
    here = Path(__file__).resolve().parent.parent
    sync_py = here/'bin'/'mcp-auto-sync.py'
    rc = subprocess.call([sys.executable, str(sync_py), 'sync'])
    sys.exit(rc)

def cmd_check(args):
    here = Path(__file__).resolve().parent.parent
    script = here/'scripts'/'mcp-check.sh'
    rc = subprocess.call(['bash', str(script)])
    sys.exit(rc)

def build_subset(names):
    obj, servers = load_central_servers()
    sel = {}
    for n in names:
        if n in servers:
            sel[n] = servers[n]
    return sel

def apply_codex(subset):
    p = HOME/'.codex'/'config.toml'
    if not p.exists():
        print(f"[ERR] Codex 配置不存在: {p}")
        return 1
    keys = sorted(list(subset.keys()))
    if DRY_RUN:
        print(f"[DRY-RUN] 将应用到 Codex: {p}")
        print("  keys:", ', '.join(keys) if keys else '(none)')
        return 0
    backup(p)
    text = p.read_text(encoding='utf-8')
    # 清理旧块 + 所有 [mcp_servers.*]
    text = re.sub(r"\n*# === MCP Servers 配置（由 MCP (?:Local Manager|Central) 生成）===\n(?:.|\n)*?(?=\n?# ===|\Z)", "\n", text)
    text = re.sub(r"(?ms)^\[mcp_servers\.[^\]]+\][\s\S]*?(?=^\[|\Z)", "", text)
    lines = ["\n# === MCP Servers 配置（由 MCP Local Manager 生成）==="]
    for name,info in subset.items():
        lines.append(f"\n[mcp_servers.{name}]")
        # Codex: 增加启动超时，避免默认 10s 超时（npx 首次拉取较慢）
        lines.append("startup_timeout_sec = 60")
        lines.append(f"command = \"{info.get('command','')}\"")
        args = info.get('args') or []
        if args:
            lines.append('args = ' + json.dumps(args))
        env = info.get('env') or {}
        if env:
            lines.append(f"\n[mcp_servers.{name}.env]")
            for k,v in env.items():
                lines.append(f"{k} = \"{v}\"")
    new_block='\n'.join(lines)+"\n"
    p.write_text(text.rstrip()+"\n"+new_block, encoding='utf-8')
    print(f"[OK] 已应用到 Codex: {p}")
    return 0

def apply_json_map(label, path: Path, subset: dict, top_key='mcpServers'):
    obj = load_json(path, {})
    keys = sorted(list((subset or {}).keys()))
    if DRY_RUN:
        print(f"[DRY-RUN] 将应用到 {label}: {path}")
        print("  keys:", ', '.join(keys) if keys else '(none)')
        return 0
    if top_key == 'servers':
        obj['servers'] = subset
    else:
        obj[top_key] = subset
        if label == 'Gemini':
            obj.setdefault('mcp', {})['allowed'] = sorted(subset.keys())
    backup(path)
    save_json(path, obj)
    print(f"[OK] 已应用到 {label}: {path}")
    return 0

def apply_claude(subset, verbose: bool=False):
    # 文件端
    apply_json_map('Claude(文件)', HOME/'.claude'/'settings.json', subset, 'mcpServers')
    # 注册表端：移除多余，补齐缺失
    if DRY_RUN:
        # 仅预览将要执行的注册表命令，不实际调用 `claude mcp`
        obj,_ = load_central_servers()
        servers = obj.get('servers') or {}
        want = sorted(subset.keys())
        print('[DRY-RUN] 将对齐 Claude 注册表（预览）')
        print('  keys:', ', '.join(want) if want else '(none)')
        for n in want:
            info = servers.get(n) or {}
            cmd = ['claude','mcp','add','--transport','stdio', n]
            for k,v in (info.get('env') or {}).items():
                cmd += ['-e', f'{k}={v}']
            cmd += ['--', _expand_tilde(info.get('command',''))]
            cmd += [ _expand_tilde(str(a)) for a in (info.get('args') or []) ]
            # 总是输出将要执行的命令（简洁预览），详细标记由 -v 控制
            print('[DRY-RUN]', ' '.join(cmd))
        print('  注：dry-run 不会执行 `claude mcp list/remove/add`')
        return 0
    try:
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=30)
        have=set()
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        for line in text.splitlines():
            if ':' in line:
                have.add(line.split(':',1)[0].strip())
    except Exception:
        have=set()
    want=set(subset.keys())
    # 先移除多余
    remove_ok=[]; remove_fail=[]
    for n in sorted(have-want):
        try:
            cmd_rm = ['claude','mcp','remove',n]
            if verbose:
                print('[VERBOSE]', ' '.join(cmd_rm))
            r = subprocess.run(cmd_rm, check=False, timeout=10)
            (remove_ok if r.returncode==0 else remove_fail).append(n)
        except Exception:
            remove_fail.append(n)
    # 再“强制重注册”目标集合，确保命令/参数与中央清单一致
    obj,_ = load_central_servers()
    servers = obj.get('servers') or {}
    add_ok=[]; add_fail=[]
    for n in sorted(want):
        info = servers.get(n) or {}
        # 先尝试移除旧记录，忽略错误
        try:
            subprocess.run(['claude','mcp','remove',n], check=False, timeout=10)
        except Exception:
            pass
        # 重新添加为 stdio + 中央清单命令
        cmd = ['claude','mcp','add','--transport','stdio', n]
        for k,v in (info.get('env') or {}).items():
            cmd += ['-e', f'{k}={v}']
        # 展开路径
        cmd += ['--', _expand_tilde(info.get('command',''))]
        cmd += [ _expand_tilde(str(a)) for a in (info.get('args') or []) ]
        try:
            if verbose:
                print('[VERBOSE]', ' '.join(cmd))
            r = subprocess.run(cmd, check=False, timeout=45)
            (add_ok if r.returncode==0 else add_fail).append(n)
        except Exception:
            add_fail.append(n)
    # 汇总
    total_add = len(add_ok)+len(add_fail)
    total_rm = len(remove_ok)+len(remove_fail)
    print('[OK] Claude 注册表已与所选集合对齐')
    if total_rm:
        print(f"  remove: ok={len(remove_ok)} fail={len(remove_fail)}" + (f"; failed=[{', '.join(remove_fail)}]" if remove_fail else ''))
    if total_add:
        print(f"  add   : ok={len(add_ok)} fail={len(add_fail)}" + (f"; failed=[{', '.join(add_fail)}]" if add_fail else ''))
    return 0

def cmd_apply_cli(args):
    subset = build_subset(args.servers.split(','))
    if not subset:
        print('[ERR] 服务器名无效或为空')
        return 1
    client = args.client
    if client == 'claude':
        return apply_claude(subset, verbose=getattr(args,'verbose',False))
    elif client == 'codex':
        return apply_codex(subset)
    elif client == 'gemini':
        return apply_json_map('Gemini', HOME/'.gemini'/'settings.json', subset, 'mcpServers')
    elif client == 'iflow':
        return apply_json_map('iFlow', HOME/'.iflow'/'settings.json', subset, 'mcpServers')
    elif client == 'droid':
        return apply_json_map('Droid', HOME/'.factory'/'mcp.json', subset, 'mcpServers')
    elif client == 'cursor':
        return apply_json_map('Cursor', HOME/'.cursor'/'mcp.json', subset, 'mcpServers')
    elif client == 'vscode-user':
        return apply_json_map('VS Code(User)', HOME/'.config'/'Code'/'User'/'mcp.json', subset, 'servers')
    elif client == 'vscode-insiders':
        return apply_json_map('VS Code(Insiders)', HOME/'.config'/'Code - Insiders'/'User'/'mcp.json', subset, 'servers')
    else:
        print('[ERR] 未知 client')
        return 2

def cmd_pick(args):
    # 简易交互：数字选择客户端 + 多选服务
    clients = [
        ('claude','Claude CLI'),
        ('codex','Codex CLI'),
        ('gemini','Gemini'),
        ('iflow','iFlow'),
        ('droid','Droid CLI'),
        ('cursor','Cursor'),
        ('vscode-user','VS Code(User)'),
        ('vscode-insiders','VS Code(Insiders)')
    ]
    print('选择目标 CLI/IDE:')
    for i,(key,label) in enumerate(clients, start=1):
        print(f'  {i}) {label} [{key}]')
    cidx = int(input('输入编号: ').strip() or '1')
    client = clients[cidx-1][0]
    # 服务器多选
    _, servers = load_central_servers()
    names = sorted(servers.keys())
    print('\n选择要启用的 MCP（空格分隔编号）:')
    for i,n in enumerate(names, start=1):
        print(f'  {i:2}) {n}')
    picks = input('输入编号列表: ').strip().split()
    chosen = []
    for p in picks:
        if p.isdigit() and 1 <= int(p) <= len(names):
            chosen.append(names[int(p)-1])
    if not chosen:
        print('[ERR] 未选择任何服务器')
        return 1
    print(f'将应用到 {client}:', ', '.join(chosen))
    ok = input('确认? [y/N]: ').strip().lower() == 'y'
    if not ok:
        print('已取消')
        return 0
    return cmd_apply_cli(argparse.Namespace(client=client, servers=','.join(chosen), verbose=getattr(args,'verbose',False)))

def main():
    p = argparse.ArgumentParser(prog='mcp', description='MCP 配置集/开关与按客户端落地（已移除 nvm 相关功能）')
    p.add_argument('-v','--verbose', action='store_true', help='显示更详细的命令与执行信息')
    p.add_argument('-n','--dry-run', action='store_true', help='仅预览：不写入文件、不运行 `claude mcp`、不执行目标命令')
    sub = p.add_subparsers(dest='cmd', required=True)

    sp_st = sub.add_parser('status', help='查看按客户端/IDE 的实际启用状态；也可用：mcp status codex')
    sp_st.add_argument('client_pos', nargs='?', help='客户端别名，如 claude/codex/vscode 等')
    sp_st.add_argument('--client', choices=['claude-file','claude-reg','codex','gemini','iflow','droid','cursor','vscode-user','vscode-ins'], help='仅查看指定客户端（更精确）')
    sp_st.add_argument('--central', action='store_true', help='同时显示中央清单视图')
    sp_st.set_defaults(func=cmd_status)

    # 已移除：on/off/only

    # 已移除：profile-save / profile-apply

    # 新增：针对单个客户端/IDE 的专用落地
    sp_ac = sub.add_parser('apply-cli', help='将所选服务器仅应用到指定 CLI/IDE 的配置文件')
    sp_ac.add_argument('--client', required=True, choices=['claude','codex','gemini','iflow','droid','cursor','vscode-user','vscode-insiders'])
    sp_ac.add_argument('--servers', required=True, help='以逗号分隔的服务器名，如 context7,serena')
    sp_ac.add_argument('-v','--verbose', action='store_true', help='显示更详细的命令与执行信息（仅部分 client 生效）')
    sp_ac.set_defaults(func=cmd_apply_cli)

    sp_pick = sub.add_parser('pick', help='交互式选择目标 CLI 与服务器集合并应用')
    sp_pick.add_argument('-v','--verbose', action='store_true', help='显示更详细的命令与执行信息（仅部分 client 生效）')
    sp_pick.set_defaults(func=cmd_pick)

    # 已移除：sync（全量同步）
    sp_ide = sub.add_parser('ide-all', help='将全部 MCP 写入 IDE（Cursor/VS Code），忽略启用标记')
    sp_ide.add_argument('-y','--yes', action='store_true', help='不询问直接执行')
    sp_ide.set_defaults(func=cmd_ide_all)
    sp_run = sub.add_parser('run', help='按客户端应用集合后启动命令，例如：mcp run --client claude --servers context7,serena -- claude')
    sp_run.add_argument('--client', required=True, choices=['claude','codex','gemini','iflow','droid','cursor','vscode-user','vscode-insiders'])
    sp_run.add_argument('--servers', required=True, help='以逗号分隔的服务器名')
    sp_run.add_argument('exec', nargs=argparse.REMAINDER, help='在 -- 之后的启动命令')
    sp_run.set_defaults(func=cmd_run)
    sub.add_parser('check', help='只读体检').set_defaults(func=cmd_check)

    args = p.parse_args()
    global DRY_RUN
    DRY_RUN = bool(getattr(args, 'dry_run', False))
    rc = args.func(args)
    if isinstance(rc, int):
        sys.exit(rc)

if __name__ == '__main__':
    main()
