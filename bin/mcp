#!/usr/bin/env python3
from __future__ import annotations
# mcp: 轻量命令行，用于按需启用/禁用 MCP 服务器、应用配置集(profile)，
#      并将所选集合落地到指定 CLI/IDE（不再提供 nvm 相关切换）。

import argparse, json, os, re, shutil, subprocess, sys, platform
from pathlib import Path

## 确保可导入顶层包（mcp_cli 等）
_BASE = Path(__file__).resolve().parent.parent
if str(_BASE) not in sys.path:
    sys.path.insert(0, str(_BASE))

# Import validation module with graceful fallback
try:
    from mcp_validation import (
        validate_mcp_servers_config, 
        MCPValidationError, 
        MCPSchemaError, 
        MCPConfigError,
        format_validation_error
    )
    VALIDATION_AVAILABLE = True
except ImportError:
    # Fallback when validation module is not available
    VALIDATION_AVAILABLE = False
    def validate_mcp_servers_config(config_path): return {}
    class MCPValidationError(Exception): pass
    class MCPSchemaError(Exception): pass
    class MCPConfigError(Exception): pass
    def format_validation_error(error): return f"❌ 配置错误: {str(error)}"

HOME = Path.home()
CENTRAL = HOME/'.mcp-central'/'config'/'mcp-servers.json'

# 全局开关：dry-run（仅预览，不落地）
# 交互版：不再支持全局 dry-run/verbose 参数

def load_json(p: Path, default, error_context: str = ""):
    """Load JSON file with enhanced error handling.
    
    Args:
        p: Path to the JSON file
        default: Default value to return on error
        error_context: Additional context for error messages
        
    Returns:
        Parsed JSON object or default value
    """
    if not p.exists():
        return default
    try:
        content = p.read_text(encoding='utf-8')
        if not content.strip():
            if error_context:
                print(f"⚠️ 警告: {error_context} - 文件为空: {p}", file=sys.stderr)
            return default
        return json.loads(content)
    except json.JSONDecodeError as e:
        if error_context:
            print(f"❌ {error_context} - JSON 解析错误: {p}", file=sys.stderr)
            print(f"   错误位置: 行 {e.lineno}, 列 {e.colno}", file=sys.stderr)
            if e.msg:
                print(f"   错误信息: {e.msg}", file=sys.stderr)
        return default
    except Exception as e:
        if error_context:
            print(f"❌ {error_context} - 读取文件失败: {p}", file=sys.stderr)
            print(f"   错误信息: {e}", file=sys.stderr)
        return default

def save_json(p: Path, obj: dict):
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding='utf-8')

def backup(p: Path):
    if not p.exists():
        return None
    b = p.with_name(p.name + '.backup')
    shutil.copy2(p, b)
    return b

def load_central_servers():
    """Load central MCP servers configuration with validation.
    
    Returns:
        tuple: (config_dict, servers_dict)
    """
    # First try to validate the configuration
    validation_passed = False
    obj = {}
    
    if VALIDATION_AVAILABLE and CENTRAL.exists():
        try:
            obj = validate_mcp_servers_config(CENTRAL)
            validation_passed = True
            print("✅ 中央配置已通过 schema 验证", file=sys.stderr) if getattr(load_central_servers, '_verbose', False) else None
        except (MCPValidationError, MCPSchemaError) as e:
            print(format_validation_error(e), file=sys.stderr)
            print("⚠️  警告: Schema 验证失败，使用基本 JSON 解析（功能可能受限）", file=sys.stderr)
            # Fall back to basic JSON loading
            obj = load_json(CENTRAL, {}, "中央配置验证失败")
        except Exception as e:
            print(f"❌ 验证过程发生未知错误: {e}", file=sys.stderr)
            print("⚠️  警告: 使用基本 JSON 解析", file=sys.stderr)
            obj = load_json(CENTRAL, {}, "中央配置验证异常")
    else:
        # Validation not available, use basic loading
        obj = load_json(CENTRAL, {}, "中央配置加载")
    
    # Extract servers with error handling
    servers = obj.get('servers') or {}
    if not isinstance(servers, dict):
        print("❌ 错误: 'servers' 字段必须是对象格式", file=sys.stderr)
        servers = {}
    
    # Validate individual servers if validation is available
    if VALIDATION_AVAILABLE and validation_passed:
        from mcp_validation import validate_server_config
        for server_name, server_info in servers.items():
            try:
                validate_server_config(server_name, server_info)
            except MCPValidationError as e:
                print(f"⚠️  服务器配置警告 - {server_name}: {e}", file=sys.stderr)
    
    return obj, servers

def write_central_servers(obj):
    backup(CENTRAL)
    save_json(CENTRAL, obj)

# 注：已移除 nvm 与中央清单开关控制逻辑

def list_servers():
    obj, servers = load_central_servers()
    rows = []
    for n, v in sorted(servers.items()):
        en = bool(v.get('enabled', True))
        cmd = v.get('command','')
        rows.append((n, 'on' if en else 'off', cmd))
    print("中央清单（启用开关与命令路径）")
    print("name                        state  command")
    print("-"*60)
    for n,st,cmd in rows:
        print(f"{n:26} {st:5}  {cmd}")

def _json_keys(path: Path, pref_key='mcpServers', error_context: str = ""):
    """Extract keys from JSON file with error handling.
    
    Args:
        path: Path to the JSON file
        pref_key: Preferred key to look for
        error_context: Context for error messages
        
    Returns:
        set: Set of keys found
    """
    obj = load_json(path, {}, error_context or f"读取 {path.name} 配置")
    if isinstance(obj.get(pref_key), dict):
        return set(obj[pref_key].keys())
    if isinstance(obj.get('servers'), dict):
        return set(obj['servers'].keys())
    return set()

def _codex_keys():
    p = HOME/'.codex'/'config.toml'
    if not p.exists():
        return set()
    try:
        import tomllib
        conf = tomllib.loads(p.read_text(encoding='utf-8'))
        m = conf.get('mcp_servers', {}) or {}
        return {k for k in m.keys() if not k.endswith('.env')}
    except Exception:
        # 简易回退：正则提取 [mcp_servers.NAME] 段
        import re
        names = set()
        for line in p.read_text(encoding='utf-8').splitlines():
            line = line.strip()
            m = re.match(r"^\[mcp_servers\.([^\]]+)\]$", line)
            if m:
                name = m.group(1)
                if not name.endswith('.env'):
                    names.add(name)
        return names

def _claude_registered():
    """更稳健地读取 Claude 注册表。
    - 延长超时（30s），适配“Claude Code 智能启动”的网络探测
    - 合并 stdout+stderr 解析，避免只读 stdout 漏项
    """
    try:
        # 测试/CI 环境可能无 Claude 或输出阻塞，将超时降到 3s，并允许通过 CLAUDE_LIST_TIMEOUT 秒覆盖
        t = float(os.environ.get('CLAUDE_LIST_TIMEOUT', '3'))
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=t)
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        reg = set()
        for line in text.splitlines():
            if ':' in line:
                reg.add(line.split(':',1)[0].strip())
        return reg
    except Exception:
        return set()

def _print_client(label, present, universe):
    present = sorted(present)
    absent = sorted(set(universe) - set(present))
    print(f"\n[{label}]")
    print("  on : "+ (', '.join(present) if present else '无'))
    print("  off: "+ (', '.join(absent) if absent else '无'))

def _normalize_client(alias: str|None):
    if not alias:
        return None
    a = alias.strip().lower()
    mapping = {
        'claude': 'claude-file',
        'claude-file': 'claude-file',
        'claude-reg': 'claude-reg',
        'codex': 'codex',
        'gemini': 'gemini',
        'iflow': 'iflow',
        'droid': 'droid',
        'cursor': 'cursor',
        'vscode': 'vscode-user',
        'vscode-user': 'vscode-user',
        'vscode-insiders': 'vscode-ins',
        'vscode-ins': 'vscode-ins',
        'insiders': 'vscode-ins',
    }
    return mapping.get(a)

def _expand_tilde(v):
    if isinstance(v, str):
        try:
            return os.path.expanduser(v)
        except Exception:
            return v
    return v

def _expand_entry(entry: dict):
    if not isinstance(entry, dict):
        return entry
    e = dict(entry)
    if 'command' in e:
        e['command'] = _expand_tilde(e['command'])
    if 'args' in e and isinstance(e['args'], list):
        e['args'] = [_expand_tilde(a) for a in e['args']]
    return e

def _is_macos():
    # 允许通过 MCP_OS=darwin 覆盖，便于测试
    v = os.environ.get('MCP_OS')
    if v:
        return v.lower() in ('darwin','mac','macos','osx')
    return platform.system() == 'Darwin'

def _vscode_user_path():
    if _is_macos():
        return HOME/'Library'/'Application Support'/'Code'/'User'/'mcp.json'
    return HOME/'.config'/'Code'/'User'/'mcp.json'

def _vscode_insiders_path():
    if _is_macos():
        return HOME/'Library'/'Application Support'/'Code - Insiders'/'User'/'mcp.json'
    return HOME/'.config'/'Code - Insiders'/'User'/'mcp.json'

def cmd_status(args):
    # 委托模块实现（阶段一拆分）
    from mcp_cli.commands import status as _status
    return _status.run(args)

def cmd_run(args):
    from mcp_cli.commands import run as _run
    setattr(args, '_dry_run', False)
    return _run.run(args)

## 已移除：cmd_on/cmd_off/cmd_only（中央清单开关不再作为入口）

## 已移除：cmd_enable_all（默认视为全部启用）

 

def cmd_sync(args):
    here = Path(__file__).resolve().parent.parent
    sync_py = here/'bin'/'mcp-auto-sync.py'
    rc = subprocess.call([sys.executable, str(sync_py), 'sync'])
    sys.exit(rc)

def cmd_central(args):
    from mcp_cli.commands import central as _central
    setattr(args, '_dry_run', False)
    return _central.run(args)

def cmd_check(args):
    # 委托模块实现（阶段一拆分）
    from mcp_cli.commands import check as _check
    return _check.run(args)

def build_subset(names):
    from mcp_cli.commands.run import build_subset as _bs
    return _bs(names)

def _strip_toml_mcp_servers_block(text: str) -> str:
    # 已迁移到 mcp_cli.utils.strip_toml_mcp_servers_block，保留向后兼容
    from mcp_cli.utils import strip_toml_mcp_servers_block as _s
    return _s(text)

def apply_codex(subset):
    from mcp_cli.commands.run import apply_codex as _ac
    return _ac(subset, dry_run=False)

def _clear_json_map(label: str, path: Path, top_key='mcpServers', extra: str|None=None):
    """将 JSON 配置中的 MCP 节点清空（并备份）。
    - top_key 为 'servers' 或 'mcpServers' 等
    - extra 可选：例如 'gemini.allowed'，会额外清空
    """
    # 交互模式不再支持 CLI dry-run；预览在交互里完成
    if not path.exists():
        print(f"[INFO] 跳过 {label}（配置不存在）: {path}")
        return 0
    obj = load_json(path, {})
    if top_key == 'servers':
        obj['servers'] = {}
    else:
        obj[top_key] = {}
        if label.startswith('Gemini'):
            obj.setdefault('mcp', {})['allowed'] = []
    if extra == 'gemini.allowed':
        obj.setdefault('mcp', {})['allowed'] = []
    backup(path)
    save_json(path, obj)
    print(f"[OK] 已清空 {label}: {path}")
    return 0

def _clear_claude_registry(verbose: bool=False):
    """移除 Claude CLI 的 mcp 注册表条目。"""
    try:
        out = subprocess.run(['claude','mcp','list'], capture_output=True, text=True, timeout=30)
        text = (out.stdout or '') + "\n" + (out.stderr or '')
        names = []
        for line in text.splitlines():
            if ':' in line:
                names.append(line.split(':',1)[0].strip())
    except Exception:
        names = []
    if not names:
        if verbose:
            print('[INFO] Claude 注册表无条目需清理')
        return 0
    ok=0; fail=0
    for n in names:
        try:
            cmd = ['claude','mcp','remove', n]
            if verbose:
                print('[VERBOSE]', ' '.join(cmd))
            r = subprocess.run(cmd, check=False, timeout=10)
            ok += 1 if r.returncode == 0 else 0
            fail += 1 if r.returncode != 0 else 0
        except Exception:
            fail += 1
    print(f"[OK] 已清理 Claude 注册表: ok={ok} fail={fail}")
    return 0

def cmd_undo(args):
    """从 *.backup 恢复；若未提供 dest，尝试基于文件名推断原路径。"""
    backup_path = Path(args.backup).expanduser()
    dest = Path(args.dest).expanduser() if getattr(args, 'dest', None) else None
    if not backup_path.exists():
        print(f"[ERR] 备份文件不存在: {backup_path}")
        return 1
    if dest is None:
        name = backup_path.name
        # 先去掉 .backup 尾缀
        if name.endswith('.backup'):
            name = name[:-7]
        # 兼容旧格式：config.json.20251125_143022.backup / config.20251125_143022.backup
        import re
        m = re.match(r"^(?P<base>.+)\.(?P<ts>\d{8}_\d{6})$", name)
        base = m.group('base') if m else name
        dest = backup_path.with_name(base)
    try:
        dest.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(backup_path, dest)
        print(f"[OK] 已恢复到: {dest}")
        return 0
    except Exception as e:
        print(f"[ERR] 恢复失败: {e}")
        return 1

def apply_json_map(label, path: Path, subset: dict, top_key='mcpServers'):
    from mcp_cli.commands.run import apply_json_map as _aj
    return _aj(label, path, subset, top_key, dry_run=False)

def apply_claude(subset, verbose: bool=False):
    from mcp_cli.commands.run import apply_claude as _acl
    return _acl(subset, verbose=verbose, dry_run=False)

def main():
    p = argparse.ArgumentParser(
        prog='mcp',
        formatter_class=__import__('argparse').RawTextHelpFormatter,
        description=(
            '交互优先的 MCP 管理工具\n'
            '操作心法: 运行命令 -> 按数字选择 -> 查看变更摘要 -> 确认写入\n'
            '小贴士: 输入 ? 查看建议; 输入 0 返回上一级; 回车使用默认/跳过'
        ),
        epilog=(
            '常用入口:\n'
            '  - mcp run      进入交互式向导, 按客户端落地所选 MCP (最后可选启动)\n'
            '  - mcp central  进入交互式向导, 管理中央清单 (CRUD/模板/导入导出/校验/体检)\n'
            '只读命令:\n'
            '  - mcp status [client]  查看按客户端/IDE 的实际启用状态\n'
            '  - mcp check            轻量体检 (不改动配置)\n'
        ),
    )
    sub = p.add_subparsers(dest='cmd', required=True)

    sp_st = sub.add_parser('status', help='查看按客户端/IDE 的实际启用状态；也可用：mcp status codex')
    sp_st.add_argument('client_pos', nargs='?', help='客户端别名，如 claude/codex/vscode 等')
    sp_st.add_argument('--client', choices=['claude-file','claude-reg','codex','gemini','iflow','droid','cursor','vscode-user','vscode-ins'], help='仅查看指定客户端（更精确）')
    sp_st.add_argument('--central', action='store_true', help='同时显示中央清单视图')
    sp_st.set_defaults(func=cmd_status)

    # 已移除：on/off/only

    # 已移除：profile-save / profile-apply
    # （已移除 apply-cli 子命令）

    # 已移除：pick

    # 已移除：sync（全量同步）
    sp_run = sub.add_parser('run', help='交互式下发所需 MCP；支持预设场景、非交互参数与差异预览')
    sp_run.add_argument('--client', help='预选客户端（跳过交互）')
    sp_run.add_argument('--servers', help='预选服务器列表，逗号分隔（跳过交互）')
    sp_run.add_argument('--preset', help='预设场景包名称（与交互菜单一致）')
    sp_run.add_argument('--yes', action='store_true', help='非交互模式自动确认写入')
    sp_run.add_argument('--dry-run', action='store_true', help='仅预览差异，不写入')
    sp_run.set_defaults(func=cmd_run)
    # 旧版 central 定义块已移除（统一使用新版 central 定义）

    sub.add_parser('check', help='只读体检').set_defaults(func=cmd_check)

    # central：管理中央清单
    sp_central = sub.add_parser('central', help='交互式管理中央 MCP 清单（新增/更新/模板/导入导出/校验/体检）')
    sc = sp_central.add_subparsers(dest='central_cmd', required=False)
    # list
    sc_list = sc.add_parser('list', help='列出所有服务')
    sc_list.add_argument('--json', action='store_true', help='JSON 输出')
    sc_list.add_argument('-i','--interactive', action='store_true', help='交互选择')
    # show
    sc_show = sc.add_parser('show', help='查看某个服务完整配置')
    sc_show.add_argument('name', nargs='?')
    sc_show.add_argument('--json', action='store_true')
    sc_show.add_argument('-i','--interactive', action='store_true')
    # add
    sc_add = sc.add_parser('add', help='新增服务')
    sc_add.add_argument('name', nargs='?')
    sc_add.add_argument('--command')
    sc_add.add_argument('--args', nargs='+')
    sc_add.add_argument('--env', nargs='*', help='KEY=VAL ...')
    sc_add.add_argument('--headers', nargs='*', help='K=V ...')
    sc_add.add_argument('--type')
    sc_add.add_argument('--url')
    sc_add.add_argument('--enabled', type=lambda x: x.lower()=='true')
    sc_add.add_argument('--json', action='store_true')
    sc_add.add_argument('-i','--interactive', action='store_true')
    # update
    sc_upd = sc.add_parser('update', help='更新服务字段')
    sc_upd.add_argument('name', nargs='?')
    sc_upd.add_argument('--rename')
    sc_upd.add_argument('--command')
    sc_upd.add_argument('--type')
    sc_upd.add_argument('--url')
    sc_upd.add_argument('--enabled', type=lambda x: x.lower()=='true')
    sc_upd.add_argument('--prepend-arg', nargs='*')
    sc_upd.add_argument('--append-arg', nargs='*')
    sc_upd.add_argument('--remove-arg', nargs='*')
    sc_upd.add_argument('--set-env', nargs='*', help='KEY=VAL ...')
    sc_upd.add_argument('--unset-env', nargs='*')
    sc_upd.add_argument('--set-header', nargs='*', help='K=V ...')
    sc_upd.add_argument('--unset-header', nargs='*')
    sc_upd.add_argument('--json', action='store_true')
    sc_upd.add_argument('-i','--interactive', action='store_true')
    # remove
    sc_rm = sc.add_parser('remove', help='删除服务')
    sc_rm.add_argument('name', nargs='?')
    sc_rm.add_argument('--json', action='store_true')
    sc_rm.add_argument('-i','--interactive', action='store_true')
    # enable/disable
    sc_en = sc.add_parser('enable', help='启用服务')
    sc_en.add_argument('name', nargs='?')
    sc_en.add_argument('--json', action='store_true')
    sc_en.add_argument('-i','--interactive', action='store_true')
    sc_dis = sc.add_parser('disable', help='禁用服务')
    sc_dis.add_argument('name', nargs='?')
    sc_dis.add_argument('--json', action='store_true')
    sc_dis.add_argument('-i','--interactive', action='store_true')
    # export
    sc_exp = sc.add_parser('export', help='导出 central JSON（默认 stdout）')
    sc_exp.add_argument('--file')
    sc_exp.add_argument('--json', action='store_true')
    sc_exp.add_argument('-i','--interactive', action='store_true')
    # import
    sc_imp = sc.add_parser('import', help='导入 central JSON（默认 merge）')
    sc_imp.add_argument('--file')
    sc_imp.add_argument('--replace', action='store_true', help='用导入内容替换现有')
    sc_imp.add_argument('--prefer-incoming', action='store_true', help='merge 冲突时偏向导入项')
    sc_imp.add_argument('--json', action='store_true')
    sc_imp.add_argument('-i','--interactive', action='store_true')
    # template
    sc_tpl = sc.add_parser('template', help='用模板创建')
    sc_tpl.add_argument('template', nargs='?')
    sc_tpl.add_argument('--name')
    sc_tpl.add_argument('--from', dest='from_path')
    sc_tpl.add_argument('--command')
    sc_tpl.add_argument('--args', nargs='*')
    sc_tpl.add_argument('--env', nargs='*')
    sc_tpl.add_argument('--json', action='store_true')
    sc_tpl.add_argument('-i','--interactive', action='store_true')
    # dup
    sc_dup = sc.add_parser('dup', help='复制服务')
    sc_dup.add_argument('src', nargs='?')
    sc_dup.add_argument('dest', nargs='?')
    sc_dup.add_argument('--json', action='store_true')
    sc_dup.add_argument('-i','--interactive', action='store_true')
    # validate
    sc_val = sc.add_parser('validate', help='校验 central 配置')
    sc_val.add_argument('--json', action='store_true')
    # doctor
    sc_doc = sc.add_parser('doctor', help='只读体检（不联网）')
    sc_doc.add_argument('--json', action='store_true')

    # 复用上方已定义的 cmd_central
    sp_central.set_defaults(func=cmd_central)

    # undo：从备份恢复
    sp_undo = sub.add_parser('undo', help='从 *.backup 文件恢复原始配置')
    sp_undo.add_argument('backup', help='备份文件路径（*.backup）')
    sp_undo.add_argument('--dest', help='可选：明确指定恢复目标路径')
    sp_undo.set_defaults(func=cmd_undo)

    args = p.parse_args()
    rc = args.func(args)
    if isinstance(rc, int):
        sys.exit(rc)

if __name__ == '__main__':
    main()
